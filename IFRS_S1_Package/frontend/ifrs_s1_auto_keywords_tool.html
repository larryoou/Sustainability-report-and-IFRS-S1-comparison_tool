<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>IFRS S1 è‡ªå‹•é—œéµè©æ¯”å°å·¥å…·</title>
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Ctext y='14' font-size='14'%3E%F0%9F%93%84%3C/text%3E%3C/svg%3E">
    <!-- PDF.js (Offline-first with CDN fallback) -->
    <script>
        (function() {
            function setWorker(src) {
                console.log(`ğŸ”§ è¨­ç½® PDF Worker: ${src}`);
                if (window.pdfjsLib) {
                    window.pdfjsLib.GlobalWorkerOptions.workerSrc = src;
                    window.pdfWorkerSrcOverride = src;
                    console.log('âœ… PDF Worker è¨­ç½®å®Œæˆ');
                } else {
                    console.warn('âš ï¸ pdfjsLib å°šæœªè¼‰å…¥ï¼Œç¨å¾Œé‡è©¦...');
                    // å¦‚æœ pdfjsLib é‚„æ²’è¼‰å…¥ï¼Œç¨å¾Œé‡è©¦
                    setTimeout(() => {
                        if (window.pdfjsLib) {
                            window.pdfjsLib.GlobalWorkerOptions.workerSrc = src;
                            window.pdfWorkerSrcOverride = src;
                            console.log('âœ… PDF Worker å»¶é²è¨­ç½®å®Œæˆ');
                        }
                    }, 100);
                }
            }
            function initializePdfJS() {
                // ç¢ºä¿ pdfjsLib å·²è¼‰å…¥
                if (typeof window.pdfjsLib !== 'undefined') {
                    console.log('âœ… PDF.js åˆå§‹åŒ–å®Œæˆ');
                    window.pdfJsReady = true;
                    window.dispatchEvent(new Event('pdfjs-ready'));
                    // é€™è£¡å¯ä»¥æ·»åŠ å…¶ä»–éœ€è¦åœ¨ PDF.js è¼‰å…¥å¾ŒåŸ·è¡Œçš„ç¨‹å¼ç¢¼
                } else {
                    console.error('âŒ PDF.js åˆå§‹åŒ–å¤±æ•—ï¼špdfjsLib æœªå®šç¾©');
                }
            }
            function initializeWithoutPDF() {
                console.log('âš ï¸ åœ¨æ²’æœ‰ PDF.js çš„æƒ…æ³ä¸‹åˆå§‹åŒ–é é¢');
                window.pdfJsDisabled = true;
                window.pdfJsReady = false;
                
                // æ›´æ–°é è¼‰ç‹€æ…‹é¡¯ç¤º
                setTimeout(function() {
                    var statusEn = document.getElementById('status-en');
                    var statusA = document.getElementById('status-a');
                    var statusB = document.getElementById('status-b');
                    
                    if (statusEn) statusEn.textContent = 'PDFåŠŸèƒ½å·²ç¦ç”¨';
                    if (statusA) statusA.textContent = 'PDFåŠŸèƒ½å·²ç¦ç”¨';
                    if (statusB) statusB.textContent = 'PDFåŠŸèƒ½å·²ç¦ç”¨';
                    
                    // é¡¯ç¤ºè­¦å‘Šè¨Šæ¯çµ¦ç”¨æˆ¶
                    var warningDiv = document.createElement('div');
                    warningDiv.style.cssText = 'background:#fff3cd;border:1px solid #ffeaa7;color:#856404;padding:10px;margin:10px;border-radius:5px;';
                    warningDiv.innerHTML = 'âš ï¸ PDF åŠŸèƒ½æš«æ™‚ç„¡æ³•ä½¿ç”¨ï¼Œä½†æ‚¨ä»å¯ä»¥ä½¿ç”¨å…¶ä»–åˆ†æåŠŸèƒ½ã€‚è«‹æª¢æŸ¥ç¶²è·¯é€£æ¥æˆ–ç¨å¾Œé‡è©¦ã€‚';
                    document.body.insertBefore(warningDiv, document.body.firstChild);
                }, 1000);
            }
            function trySetLocalWorker() {
                fetch('assets/pdfjs/pdf.worker.min.js', { method: 'HEAD' })
                    .then(r => {
                        if (r.ok) {
                            console.log('âœ… ä½¿ç”¨æœ¬åœ° PDF Worker');
                            setWorker('assets/pdfjs/pdf.worker.min.js');
                        } else {
                            console.log('âš ï¸ æœ¬åœ° PDF Worker ä¸å­˜åœ¨ï¼Œä½¿ç”¨ Mozilla CDN');
                            setWorker('https://mozilla.github.io/pdf.js/build/pdf.worker.min.js');
                        }
                    })
                    .catch(() => {
                        console.log('âš ï¸ ç„¡æ³•æª¢æŸ¥æœ¬åœ° PDF Workerï¼Œä½¿ç”¨ Mozilla CDN');
                        setWorker('https://mozilla.github.io/pdf.js/build/pdf.worker.min.js');
                    });
            }
            function loadPdfJS() {
                var s = document.createElement('script');
                s.src = 'assets/pdfjs/pdf.min.js';
                s.onload = function() {
                    console.log('âœ… æœ¬åœ° PDF.js è¼‰å…¥æˆåŠŸ');
                    trySetLocalWorker();
                    initializePdfJS();
                };
                s.onerror = function() {
                    console.log('âš ï¸ æœ¬åœ° PDF.js ä¸å­˜åœ¨ï¼Œä½¿ç”¨ Mozilla å®˜æ–¹ CDN');
                    var s2 = document.createElement('script');
                    // ä½¿ç”¨ Mozilla å®˜æ–¹ CDNï¼Œæœ€å¯é 
                    s2.src = 'https://mozilla.github.io/pdf.js/build/pdf.min.js';
                    s2.onload = function() {
                        console.log('âœ… Mozilla CDN PDF.js è¼‰å…¥æˆåŠŸ');
                        setWorker('https://mozilla.github.io/pdf.js/build/pdf.worker.min.js');
                        initializePdfJS();
                    };
                    s2.onerror = function() {
                        console.error('âŒ Mozilla CDN å¤±æ•—ï¼Œå˜—è©¦ jsDelivr CDN');
                        // å˜—è©¦ jsDelivr CDN
                        var s3 = document.createElement('script');
                        s3.src = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.4.120/build/pdf.min.js';
                        s3.onload = function() {
                            console.log('âœ… jsDelivr CDN PDF.js è¼‰å…¥æˆåŠŸ');
                            setWorker('https://cdn.jsdelivr.net/npm/pdfjs-dist@3.4.120/build/pdf.worker.min.js');
                            initializePdfJS();
                        };
                        s3.onerror = function() {
                            console.error('âŒ æ‰€æœ‰ PDF.js CDN éƒ½è¼‰å…¥å¤±æ•—ï¼Œç¦ç”¨ PDF åŠŸèƒ½');
                            // ç¦ç”¨ PDF åŠŸèƒ½ï¼Œä½†ä¸é˜»æ­¢é é¢å…¶ä»–åŠŸèƒ½
                            window.pdfJsDisabled = true;
                            initializeWithoutPDF();
                        };
                        // æ·»åŠ è¶…æ™‚ä¿è­·ï¼Œé˜²æ­¢è¼‰å…¥å¡ä½
                        setTimeout(function() {
                            if (!window.pdfJsReady && !window.pdfJsDisabled) {
                                console.error('âŒ PDF.js è¼‰å…¥è¶…æ™‚ï¼Œç¦ç”¨ PDF åŠŸèƒ½');
                                window.pdfJsDisabled = true;
                                initializeWithoutPDF();
                            }
                        }, 10000); // 10ç§’è¶…æ™‚
                        document.head.appendChild(s3);
                    };
                    document.head.appendChild(s2);
                };
                document.head.appendChild(s);
            }
            loadPdfJS();
        })();
    </script>
    <script src="ifrs_s1_complete_articles.js"></script>
    <style>
/* Toggle Switch Styles */
.switch {
    position: relative;
    display: inline-block;
    width: 50px;
    height: 24px;
}

.switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

.slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #ccc;
    transition: .4s;
}

.slider:before {
    position: absolute;
    content: "";
    height: 18px;
    width: 18px;
    left: 3px;
    bottom: 3px;
    background-color: white;
    transition: .4s;
}

input:checked + .slider {
    background-color: #2196F3;
}

input:focus + .slider {
    box-shadow: 0 0 1px #2196F3;
}

input:checked + .slider:before {
    transform: translateX(26px);
}

.slider.round {
    border-radius: 24px;
}

.slider.round:before {
    border-radius: 50%;
}

.setting-group {
    margin-bottom: 20px;
    padding: 15px;
    background: #f8f9fa;
    border-radius: 8px;
    border-left: 4px solid #2196F3;
}

/* å°å‡ºæ§åˆ¶é¢æ¿æ¨£å¼ */
.export-controls {
    margin-bottom: 30px;
    padding: 20px;
    background: #f0f8ff;
    border-radius: 12px;
    border: 2px solid #4285f4;
    box-shadow: 0 4px 12px rgba(66, 133, 244, 0.1);
    position: relative;
    z-index: 10;
}

.export-options {
    display: grid;
    grid-template-columns: 1fr 2fr;
    gap: 20px;
    align-items: start;
}

.export-info p {
    margin: 8px 0;
    font-size: 14px;
    color: #555;
}

.export-info span {
    font-weight: 600;
    color: #2196F3;
}

.export-buttons {
    display: flex;
    justify-content: center;
    align-items: center;
}

.export-buttons .btn-ai-special {
    grid-column: 1 / -1;
    background: linear-gradient(135deg, #ff6b6b 0%, #4ecdc4 100%);
    font-weight: 600;
    position: relative;
    overflow: hidden;
}

.export-buttons .btn-ai-special::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
    transition: left 0.5s;
}

.export-buttons .btn-ai-special:hover::before {
    left: 100%;
}

.btn-export {
    padding: 12px 16px;
    background: linear-gradient(135deg, #4285f4 0%, #34a853 100%);
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
    text-align: left;
    box-shadow: 0 2px 8px rgba(66, 133, 244, 0.2);
    position: relative;
    z-index: 20;
    pointer-events: auto;
}

.btn-export:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 16px rgba(66, 133, 244, 0.3);
}

.btn-export:active {
    transform: translateY(0);
}

@media (max-width: 768px) {
    .export-options {
        grid-template-columns: 1fr;
    }
    
    .export-buttons {
        grid-template-columns: 1fr;
    }
}

/* IFRS S1 å»ºè­°æ›¸é è¦½æ¨¡æ…‹çª—å£ */
.recommendation-modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.8);
    backdrop-filter: blur(5px);
}

.recommendation-content {
    position: relative;
    background-color: #fefefe;
    margin: 2% auto;
    padding: 0;
    border: none;
    width: 95%;
    max-width: 1200px;
    height: 90vh;
    border-radius: 12px;
    box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    display: flex;
    flex-direction: column;
}

.recommendation-header {
    padding: 20px 30px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border-radius: 12px 12px 0 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.recommendation-header h2 {
    margin: 0;
    font-size: 1.5em;
    font-weight: 600;
}

.recommendation-close {
    background: none;
    border: none;
    color: white;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
    padding: 0;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.3s;
}

.recommendation-close:hover {
    background-color: rgba(255,255,255,0.2);
}

.recommendation-toolbar {
    padding: 15px 30px;
    background: #f8f9ff;
    border-bottom: 1px solid #e1e5e9;
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 10px;
}

.recommendation-actions {
    display: flex;
    gap: 10px;
}

.recommendation-btn {
    padding: 8px 16px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.3s;
    display: flex;
    align-items: center;
    gap: 8px;
}

.recommendation-btn.primary {
    background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
    color: white;
}

.recommendation-btn.secondary {
    background: #f1f3f4;
    color: #5f6368;
    border: 1px solid #dadce0;
}

.recommendation-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

.recommendation-body {
    flex: 1;
    overflow-y: auto;
    padding: 30px;
    background: white;
}

.recommendation-document {
    max-width: 800px;
    margin: 0 auto;
    line-height: 1.8;
    color: #333;
    font-family: 'Microsoft JhengHei', 'Times New Roman', serif;
}

.recommendation-document h1 {
    text-align: center;
    color: #1a73e8;
    border-bottom: 3px solid #1a73e8;
    padding-bottom: 20px;
    margin-bottom: 30px;
    font-size: 2.2em;
}

.recommendation-document h2 {
    color: #34a853;
    margin-top: 40px;
    margin-bottom: 20px;
    font-size: 1.4em;
    border-left: 4px solid #34a853;
    padding-left: 15px;
}

.recommendation-document h3 {
    color: #ea4335;
    margin-top: 25px;
    margin-bottom: 15px;
    font-size: 1.2em;
}

.recommendation-document p {
    margin-bottom: 15px;
    text-align: justify;
}

.recommendation-document ul, .recommendation-document ol {
    margin-bottom: 20px;
    padding-left: 25px;
}

.recommendation-document li {
    margin-bottom: 8px;
}

.recommendation-highlight {
    background: linear-gradient(120deg, #a8e6cf 0%, #dcedc8 100%);
    padding: 20px;
    border-radius: 8px;
    border-left: 4px solid #4CAF50;
    margin: 20px 0;
}

.recommendation-evidence {
    background: #f8f9ff;
    border: 1px solid #e8eaed;
    border-radius: 8px;
    padding: 15px;
    margin: 15px 0;
}

.recommendation-evidence-title {
    font-weight: 600;
    color: #1a73e8;
    margin-bottom: 10px;
}

.loading-ai {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 300px;
    color: #666;
}

.loading-ai .spinner-ai {
    width: 50px;
    height: 50px;
    border: 4px solid #f3f3f3;
    border-top: 4px solid #4285f4;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: 20px;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

@media (max-width: 768px) {
    .recommendation-content {
        width: 98%;
        height: 95vh;
        margin: 1% auto;
    }
    
    .recommendation-body {
        padding: 20px;
    }
    
    .recommendation-toolbar {
        flex-direction: column;
        align-items: stretch;
    }
    
    .recommendation-actions {
        justify-content: center;
    }
}        /* ç¢ºä¿ PDF æ–‡æœ¬å±¤ä½¿ç”¨æ­£ç¢ºçš„å­—é«” */
        .textLayer {
            font-family: 'Microsoft JhengHei', 'PingFang TC', 'Microsoft YaHei', 'Heiti TC', 'LiHei Pro', sans-serif !important;
        }
        * {
            box-sizing: border-box;
        }
        body {
            font-family: 'Google Sans', 'Microsoft JhengHei', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #f8f9ff 0%, #e8f0fe 100%);
            min-height: 100vh;
            color: #202124;
            line-height: 1.6;
        }
        .main-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 24px;
        }
        .hero-section {
            text-align: center;
            padding: 60px 24px 40px;
            margin-bottom: 40px;
        }
        .hero-title {
            font-size: 3.2rem;
            font-weight: 400;
            color: #1a73e8;
            margin: 0 0 16px;
            letter-spacing: -0.02em;
        }
        .hero-subtitle {
            font-size: 1.25rem;
            color: #5f6368;
            margin: 0 0 40px;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            font-weight: 300;
        }
        .card {
            background: white;
            border-radius: 12px;
            padding: 32px;
            box-shadow: 0 2px 10px rgba(60, 64, 67, 0.15);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid rgba(218, 220, 224, 0.5);
        }
        .card:hover {
            box-shadow: 0 8px 25px rgba(60, 64, 67, 0.2);
            transform: translateY(-2px);
        }
        .card-title {
            font-size: 1.5rem;
            font-weight: 500;
            color: #202124;
            margin: 0 0 16px;
        }
        .upload-zone {
            border: 2px dashed #dadce0;
            border-radius: 8px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .upload-zone:hover, .upload-zone.dragover {
            border-color: #4285f4;
            background: rgba(66, 133, 244, 0.04);
        }
        .upload-icon {
            font-size: 3rem;
            color: #9aa0a6;
            margin-bottom: 16px;
        }
        .upload-text {
            color: #5f6368;
            font-size: 1.1rem;
        }
        .file-input {
            display: none;
        }
        .btn {
            border: none;
            padding: 12px 24px;
            border-radius: 24px;
            font-size: 1rem;
            cursor: pointer;
            font-weight: 500;
        }
        .btn-primary {
            background: #1a73e8;
            color: white;
        }
        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #e0e0e0;
            border-top: 4px solid #4285f4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .progress-bar {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: 4px;
            margin-top: 10px;
        }
        .progress-bar-inner {
            height: 8px;
            width: 0%;
            background-color: #4285f4;
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        .report-container, .preloaded-docs-container {
            margin-top: 24px;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            min-height: 50px;
            position: relative;
            z-index: 1;
        }
        .result-card {
            background: white;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 24px;
            box-shadow: 0 2px 10px rgba(60, 64, 67, 0.1);
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 16px;
            margin: 20px 0;
        }
        .stat-item {
            text-align: center;
        }
        .stat-number {
            font-size: 1.8rem;
            font-weight: 500;
            color: #1a73e8;
        }
        .stat-label {
            color: #5f6368;
            font-size: 0.9rem;
        }

        /* Multi-stage progress bar styles */
        .progress-stage {
            margin-bottom: 15px;
        }
        .progress-stage-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-weight: 500;
        }
        .progress-stage-status {
            font-size: 0.9em;
            color: #5f6368;
        }
        .progress-stage.active .progress-stage-status {
            color: #1a73e8;
            font-weight: 600;
        }
        .progress-stage.completed .progress-stage-status {
            color: #137333;
            font-weight: 600;
        }
        .keyword-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .keyword-tag {
            background: #e8f0fe;
            color: #1a73e8;
            padding: 4px 10px;
            border-radius: 16px;
            font-size: 0.9rem;
        }
        /* Evidence cards and scrolling list */
        .article-card {
            border-left: 4px solid #1a73e8;
        }
        .article-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }
        .article-meta {
            color: #5f6368;
            font-size: 0.9rem;
        }
        .evidence-list {
            max-height: 260px;
            overflow-y: auto;
            padding-right: 6px;
            border-top: 1px dashed #e0e0e0;
            margin-top: 12px;
        }
        .evidence-item {
            padding: 12px 0;
            border-bottom: 1px solid #f1f3f4;
        }
        .evidence-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }
        .badge {
            display: inline-block;
            padding: 2px 8px;
            font-size: 0.8rem;
            border-radius: 10px;
            background: #e8f0fe;
            color: #1a73e8;
        }
        .evidence-content {
            color: #202124;
        }
        .evidence-reasoning {
            margin-top: 6px;
            font-size: 0.9rem;
            color: #5f6368;
            background: #f8f9fa;
            padding: 8px;
            border-radius: 8px;
        }

        /* æ¨¡å‹é¸æ“‡é¢æ¿æ¨£å¼ */
        .model-selection-panel {
            margin-bottom: 24px;
        }
        
        .model-description {
            color: #5f6368;
            font-size: 1rem;
            margin: 8px 0 24px;
            text-align: center;
        }
        
        .model-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 16px;
            margin-bottom: 24px;
        }
        
        .model-option {
            position: relative;
        }
        
        .model-option input[type="radio"] {
            position: absolute;
            opacity: 0;
            pointer-events: none;
        }
        
        .model-card {
            display: block;
            padding: 20px;
            border: 2px solid #e8eaed;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #fafbfc;
            height: 100%;
            box-sizing: border-box;
        }
        
        .model-card:hover {
            border-color: #4285f4;
            background: rgba(66, 133, 244, 0.04);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(60, 64, 67, 0.15);
        }
        
        .model-option.selected .model-card {
            border-color: #1a73e8;
            background: rgba(26, 115, 232, 0.08);
            box-shadow: 0 2px 8px rgba(26, 115, 232, 0.2);
        }
        
        .model-header {
            display: flex;
            align-items: center;
            margin-bottom: 16px;
        }
        
        .model-icon {
            font-size: 2rem;
            margin-right: 12px;
            min-width: 40px;
        }
        
        .model-info h4 {
            margin: 0 0 4px;
            font-size: 1.2rem;
            font-weight: 600;
            color: #202124;
        }
        
        .model-info p {
            margin: 0;
            font-size: 0.9rem;
            color: #5f6368;
        }
        
        .model-specs {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }
        
        .model-specs .spec {
            background: #e8f0fe;
            color: #1967d2;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 500;
        }
        
        .model-option.selected .model-specs .spec {
            background: #1a73e8;
            color: white;
        }
        
        .model-features {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .model-features .feature {
            background: #f1f3f4;
            color: #3c4043;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
        }
        
        .model-option.selected .model-features .feature {
            background: rgba(26, 115, 232, 0.1);
            color: #1a73e8;
        }
        
        .model-status {
            text-align: center;
            padding: 12px 20px;
            background: rgba(52, 168, 83, 0.1);
            border-radius: 24px;
            border: 1px solid rgba(52, 168, 83, 0.2);
        }
        
        .status-indicator {
            font-size: 1.2rem;
            margin-right: 8px;
        }
        
        .status-text {
            font-weight: 500;
            color: #137333;
        }
        
        @media (max-width: 768px) {
            .model-options {
                grid-template-columns: 1fr;
            }
            
            .model-card {
                padding: 16px;
            }
            
            .model-header {
                margin-bottom: 12px;
            }
            
            .model-icon {
                font-size: 1.5rem;
                margin-right: 8px;
                min-width: 32px;
            }
            
            .model-info h4 {
                font-size: 1.1rem;
            }
            
            .model-info p {
                font-size: 0.85rem;
            }
        }

        /* æŠ€è¡“æ¶æ§‹ç°¡ä»‹æ¨£å¼ */
        .tech-overview {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 24px;
            margin-top: 20px;
        }

        .tech-item {
            display: flex;
            gap: 16px;
            padding: 20px;
            background: linear-gradient(135deg, #f8f9ff 0%, #e8f0fe 100%);
            border-radius: 12px;
            border: 1px solid rgba(26, 115, 232, 0.1);
            transition: all 0.3s ease;
        }

        .tech-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(26, 115, 232, 0.15);
            border-color: rgba(26, 115, 232, 0.2);
        }

        .tech-icon {
            font-size: 2rem;
            flex-shrink: 0;
            display: flex;
            align-items: flex-start;
            margin-top: 4px;
        }

        .tech-content {
            flex: 1;
        }

        .tech-content h4 {
            margin: 0 0 8px 0;
            font-size: 1.1rem;
            font-weight: 600;
            color: #1a73e8;
        }

        .tech-content p {
            margin: 0;
            font-size: 0.9rem;
            line-height: 1.5;
            color: #3c4043;
        }

        @media (max-width: 768px) {
            .tech-overview {
                grid-template-columns: 1fr;
                gap: 16px;
            }
            
            .tech-item {
                padding: 16px;
            }
            
            .tech-icon {
                font-size: 1.5rem;
            }
        }

        /* PDFå°å‡ºæŒ‰éˆ•æ¨£å¼ */
        .btn-pdf-primary {
            background: linear-gradient(135deg, #d32f2f 0%, #f44336 100%) !important;
            color: white !important;
            font-size: 1.1rem !important;
            padding: 16px 32px !important;
            border-radius: 8px !important;
            box-shadow: 0 4px 15px rgba(211, 47, 47, 0.3) !important;
            transition: all 0.3s ease !important;
            border: none !important;
            font-weight: 600 !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            gap: 8px !important;
            width: 100% !important;
            margin: 0 auto !important;
        }

        .btn-pdf-primary:hover {
            background: linear-gradient(135deg, #c62828 0%, #e53935 100%) !important;
            transform: translateY(-2px) !important;
            box-shadow: 0 6px 20px rgba(211, 47, 47, 0.4) !important;
        }

        /* HTMLé è¦½æŒ‰éˆ•æ¨£å¼ */
        .btn-html-preview {
            background: linear-gradient(135deg, #1976d2 0%, #2196f3 100%) !important;
            color: white !important;
            font-size: 1.1rem !important;
            padding: 16px 32px !important;
            border-radius: 8px !important;
            border: none !important;
            cursor: pointer !important;
            transition: all 0.3s ease !important;
            font-weight: 600 !important;
            text-transform: none !important;
            display: inline-flex !important;
            align-items: center !important;
            justify-content: center !important;
            gap: 8px !important;
            width: 100% !important;
            margin: 0 auto !important;
        }

        .btn-html-preview:hover {
            background: linear-gradient(135deg, #1565c0 0%, #1e88e5 100%) !important;
            transform: translateY(-2px) !important;
            box-shadow: 0 6px 20px rgba(25, 118, 210, 0.4) !important;
        }

        .export-buttons {
            display: flex !important;
            justify-content: center !important;
            padding: 20px 0 !important;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="hero-section">
            <h1 class="hero-title">ESGå ±å‘Šæ›¸è½‰æ›IFRS S1æ¢æ–‡è‡ªå‹•é…å°å·¥å…·</h1>
            <p class="hero-subtitle">ä¸Šå‚³æ‚¨çš„æ°¸çºŒå ±å‘Šæ›¸PDFæ–‡ä»¶ï¼Œç³»çµ±å°‡è‡ªå‹•èˆ‡IFRS S1æ¢æ–‡é€²è¡Œæ¯”å°ï¼Œä¸¦ç”Ÿæˆåˆ†æå ±å‘Šã€‚</p>
            

        </div>


        <!-- æŠ€è¡“æ¶æ§‹ç°¡ä»‹ -->
        <div class="card">
            <h2 class="card-title"> æŠ€è¡“æ¶æ§‹ç°¡ä»‹</h2>
            <div class="tech-overview">
                <div class="tech-item">
                    <div class="tech-icon"></div>
                    <div class="tech-content">
                        <h4>é›™æ¨¡å‹èåˆæ¶æ§‹</h4>
                        <p>çµåˆ EmbeddingGemma (Google) å’Œ Qwen3-Embedding (é˜¿é‡Œå·´å·´) å…©å€‹å…ˆé€²åµŒå…¥æ¨¡å‹ï¼Œé€éåŠ æ¬Šå¹³å‡èåˆ (Gemma 60% + Qwen3 40%) ç”¢ç”Ÿ896ç¶­èåˆå‘é‡ï¼Œæä¾›æ›´æº–ç¢ºçš„èªç¾©ç†è§£ã€‚</p>
                    </div>
                </div>
                <div class="tech-item">
                    <div class="tech-icon"></div>
                    <div class="tech-content">
                        <h4>FAISS åŠ é€Ÿæª¢ç´¢</h4>
                        <p>æ¡ç”¨ Facebook AI Similarity Search å‘é‡ç´¢å¼•æŠ€è¡“ï¼Œé å…ˆå»ºç«‹125æ¢ IFRS S1 æ¢æ–‡çš„å‘é‡ç´¢å¼•ï¼Œçµåˆ BM25 é—œéµè©æœç´¢ (30%) å’Œèªç¾©å‘é‡æœç´¢ (70%) çš„æ··åˆæª¢ç´¢æ¶æ§‹ï¼Œå¤§å¹…æå‡åˆ†æé€Ÿåº¦ã€‚</p>
                    </div>
                </div>
                <div class="tech-item">
                    <div class="tech-icon"></div>
                    <div class="tech-content">
                        <h4>èªç¾©æ˜ å°„ç³»çµ±</h4>
                        <p>å…§å»ºè©å½™èªç¾©æ˜ å°„å­—å…¸ï¼Œæ™ºæ…§è½‰æ› IFRS æ­£å¼è¡“èªèˆ‡ ESG å ±å‘Šæ›¸ç”¨è©ï¼Œæ”¯æ´æ¢æ–‡ç‰¹å®šåˆ†æèˆ‡è­‰æ“šå»é‡ï¼Œç¢ºä¿æ¯å€‹æ¢æ–‡æ‰¾åˆ°ç¨ç‰¹ä¸”ç›¸é—œçš„è­‰æ“šå…§å®¹ã€‚</p>
                    </div>
                </div>
            </div>
        </div>

        <div class="card">
            <h2 class="card-title">ä¸Šå‚³æ–‡ä»¶</h2>
            <div class="upload-zone">
                <input type="file" id="fileInput" class="file-input" accept=".pdf">
                <div class="upload-icon"></div>
                <p class="upload-text">é»æ“Šæˆ–æ‹–æ‹½PDFæ–‡ä»¶åˆ°é€™è£¡</p>
                <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()">é¸æ“‡æ–‡ä»¶</button>
            </div>
        </div>

        <div class="loading" id="loadingIndicator">
            <div class="card" style="padding: 24px;">
                <h3 style="text-align: center; margin-bottom: 20px; color: #1a73e8;">æ­£åœ¨é€²è¡Œæ·±åº¦åˆ†æ...</h3>
                <div id="multi-stage-progress">
                    <div class="progress-stage" id="stage-pdf">
                        <div class="progress-stage-header">
                            <span>1. PDF æ–‡ä»¶è§£æ</span>
                            <span class="progress-stage-status">å¾…è™•ç†</span>
                        </div>
                        <div class="progress-bar"><div class="progress-bar-inner"></div></div>
                    </div>
                    <div class="progress-stage" id="stage-analysis">
                        <div class="progress-stage-header">
                            <span>2. æ¢æ–‡èªç¾©åˆ†æ</span>
                            <span class="progress-stage-status">å¾…è™•ç†</span>
                        </div>
                        <div class="progress-bar"><div class="progress-bar-inner"></div></div>
                    </div>
                    <div class="progress-stage" id="stage-report">
                        <div class="progress-stage-header">
                            <span>3. ç”¢ç”Ÿåˆ†æå ±å‘Š</span>
                            <span class="progress-stage-status">å¾…è™•ç†</span>
                        </div>
                        <div class="progress-bar"><div class="progress-bar-inner"></div></div>
                    </div>
                </div>
                <div id="overall-status" style="text-align: center; margin-top: 20px; font-weight: 500; color: #5f6368;">æ­£åœ¨åˆå§‹åŒ–...</div>
            </div>
        </div>

        <!-- å ±å‘Šå°å‡ºæ§åˆ¶é¢æ¿ -->
        <div class="export-controls card" id="exportControls" style="display:none;">
            <h3>åˆ†æå ±å‘Šå°å‡º</h3>
            <div class="export-options">
                <div class="export-info">
                    <p><strong>æ–‡ä»¶åç¨±ï¼š</strong><span id="exportFileName">-</span></p>
                    <p><strong>åˆ†ææ‰€èŠ±æ™‚é–“ï¼š</strong><span id="exportAnalysisDate">-</span></p>
                    <p><strong>åŒ¹é…æ¢æ–‡ï¼š</strong><span id="exportMatchCount">-</span></p>
                </div>
                <div class="export-buttons">
                    <button class="btn btn-export btn-pdf-primary" onclick="downloadReportAsHTML()">
                        ğŸ’¾ ä¸‹è¼‰HTMLå ±å‘Š
                    </button>
                </div>
            </div>
        </div>

        <div class="report-container" id="reportContainer"></div>

        <!-- IFRS S1 å»ºè­°æ›¸é è¦½æ¨¡æ…‹çª—å£ -->
        <div id="recommendationModal" class="recommendation-modal">
            <div class="recommendation-content">
                <div class="recommendation-header">
                    <h2> IFRS S1 å»ºè­°æ›¸å ±å‘Š (AIç”Ÿæˆ)</h2>
                    <button class="recommendation-close" onclick="closeRecommendationModal()">&times;</button>
                </div>
                
                <div class="recommendation-toolbar">
                    <div class="recommendation-info">
                        <span id="recommendationStatus">æº–å‚™ç”Ÿæˆå»ºè­°æ›¸...</span>
                    </div>
                    <div class="recommendation-actions">
                        <button class="recommendation-btn secondary" onclick="regenerateRecommendation()">
                             é‡æ–°ç”Ÿæˆ
                        </button>
                        <button class="recommendation-btn primary" onclick="downloadRecommendationReport()">
                             ä¸‹è¼‰å»ºè­°æ›¸
                        </button>
                        <button class="recommendation-btn secondary" onclick="printRecommendationReport()">
                             åˆ—å°
                        </button>
                    </div>
                </div>
                
                <div class="recommendation-body">
                    <div id="recommendationContent">
                        <div class="loading-ai">
                            <div class="spinner-ai"></div>
                            <p> AIæ­£åœ¨åˆ†ææ‚¨çš„å ±å‘Šä¸¦ç”ŸæˆIFRS S1å»ºè­°æ›¸...</p>
                            <p style="font-size: 0.9em; color: #888;">é€™å¯èƒ½éœ€è¦30-60ç§’ï¼Œè«‹è€å¿ƒç­‰å€™</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="preloaded-docs-container card">
            <h3>é è¼‰IFRSæ–‡ä»¶ç‹€æ…‹</h3>
            <div id="preloaded-docs-status">
                <p><strong>IFRS S1 (EN):</strong> <span id="status-en">Loading...</span></p>
                <p><strong>IFRS S1 (A):</strong> <span id="status-a">Loading...</span></p>
                <p><strong>IFRS S1 (B):</strong> <span id="status-b">Loading...</span></p>
                <p><strong>Semantic Service:</strong> <span id="status-semantic">Checking...</span></p>
            </div>
        </div>
    </div>

    <script>
        // Apply console overrides immediately before any other code runs
        (function() {
            // Store original console methods
            const originalWarn = console.warn;
            const originalLog = console.log;
            const originalError = console.error;

            // Override console methods globally to suppress PDF.js warnings
            console.warn = function(...args) {
                // Suppress all PDF.js font-related warnings
                const message = args.join(' ');
                if (message.includes('loadFont') || message.includes('translateFont') ||
                    message.includes('CMap') || message.includes('font face') ||
                    message.includes('TT: undefined function') ||
                    message.includes('baseUrl') || message.includes('cMapUrl') ||
                    (message.includes('Warning:') && message.includes('loadFont'))) {
                    return; // Suppress the warning completely
                }
                originalWarn.apply(console, args);
            };

            console.log = function(...args) {
                // Suppress PDF.js worker messages and font warnings
                const message = args.join(' ');
                if (message.includes('loadFont') || message.includes('translateFont') ||
                    message.includes('CMap') || message.includes('font face') ||
                    message.includes('TT: undefined function') ||
                    message.includes('baseUrl') || message.includes('cMapUrl') ||
                    (message.includes('Warning:') && message.includes('loadFont'))) {
                    return; // Suppress the warning completely
                }
                originalLog.apply(console, args);
            };

            console.error = function(...args) {
                // Suppress PDF.js font-related errors but keep other errors
                const message = args.join(' ');
                if (message.includes('loadFont') || message.includes('translateFont') ||
                    message.includes('CMap') || message.includes('font face') ||
                    message.includes('TT: undefined function') ||
                    message.includes('baseUrl') || message.includes('cMapUrl')) {
                    return; // Suppress PDF.js font errors
                }
                originalError.apply(console, args);
            };

            // Override window.console as well to catch everything
            if (window.console) {
                window.console.warn = console.warn;
                window.console.log = console.log;
                window.console.error = console.error;
            }
        })();
        document.addEventListener('DOMContentLoaded', () => {
            // --- Global State and Configuration ---
            const ifrs1Data = { articles: [] };
            const ifrs1EnData = {
                articles: [
                    // ç§»é™¤ IFRS-S1-1 åˆ° IFRS-S1-19ï¼Œé€™äº›æ¢æ–‡å·²ä¸å†ä½¿ç”¨é…å°åŠŸèƒ½ï¼Œç³»çµ±å¾ IFRS-S1-21 é–‹å§‹
                ]
            };
            let preloadedPDFFiles = {};
            let analysisReportData = {};
            let sentencesByPage = [];
            let paragraphsByPage = [];

            //  PDFæ–‡å­—ç·©å­˜ç®¡ç†å™¨
            class PDFTextCache {
                constructor() {
                    this.cache = new Map();
                    this.maxCacheSize = 50; // æœ€å¤šç·©å­˜50å€‹æ–‡ä»¶
                    this.cacheKey = 'ifrs_pdf_text_cache_v1';
                    this.loadCacheFromStorage();
                }

                generateFileHash(file) {
                    // ä½¿ç”¨æ–‡ä»¶åã€å¤§å°ã€ä¿®æ”¹æ™‚é–“ç”Ÿæˆå“ˆå¸Œ
                    const hashSource = `${file.name}_${file.size}_${file.lastModified}`;
                    // ä½¿ç”¨encodeURIComponentç¢ºä¿å­—ç¬¦ä¸²å®‰å…¨ï¼Œç„¶å¾Œç”Ÿæˆå“ˆå¸Œ
                    try {
                        return btoa(encodeURIComponent(hashSource)).replace(/[+/=]/g, '').substring(0, 16);
                    } catch (e) {
                        // é™ç´šæ–¹æ¡ˆï¼šä½¿ç”¨ç°¡å–®å­—ç¬¦ä¸²å“ˆå¸Œ
                        let hash = 0;
                        for (let i = 0; i < hashSource.length; i++) {
                            const char = hashSource.charCodeAt(i);
                            hash = ((hash << 5) - hash) + char;
                            hash = hash & hash; // è½‰æ›ç‚º32ä½æ•´æ•¸
                        }
                        return Math.abs(hash).toString(36).substring(0, 16);
                    }
                }

                loadCacheFromStorage() {
                    try {
                        const stored = localStorage.getItem(this.cacheKey);
                        if (stored) {
                            const parsed = JSON.parse(stored);
                            Object.entries(parsed).forEach(([key, value]) => {
                                this.cache.set(key, {
                                    ...value,
                                    timestamp: new Date(value.timestamp)
                                });
                            });
                            console.log(` å¾æœ¬åœ°åŠ è¼‰äº† ${this.cache.size} å€‹PDFç·©å­˜`);
                        }
                    } catch (error) {
                        console.warn('PDFç·©å­˜åŠ è¼‰å¤±æ•—:', error);
                        this.cache.clear();
                    }
                }

                saveCacheToStorage() {
                    try {
                        const cacheObj = {};
                        this.cache.forEach((value, key) => {
                            cacheObj[key] = {
                                ...value,
                                timestamp: value.timestamp.toISOString()
                            };
                        });
                        localStorage.setItem(this.cacheKey, JSON.stringify(cacheObj));
                    } catch (error) {
                        console.warn('PDFç·©å­˜ä¿å­˜å¤±æ•—:', error);
                    }
                }

                getCachedText(file) {
                    const hash = this.generateFileHash(file);
                    const cached = this.cache.get(hash);
                    
                    if (cached) {
                        // æª¢æŸ¥ç·©å­˜æ˜¯å¦éæœŸ (7å¤©)
                        const daysSinceCached = (Date.now() - cached.timestamp) / (1000 * 60 * 60 * 24);
                        if (daysSinceCached < 7) {
                            console.log(` ä½¿ç”¨PDFç·©å­˜: ${file.name} (${daysSinceCached.toFixed(1)}å¤©å‰)`);
                            return cached;
                        } else {
                            console.log(` PDFç·©å­˜éæœŸï¼Œåˆ é™¤: ${file.name}`);
                            this.cache.delete(hash);
                            this.saveCacheToStorage();
                        }
                    }
                    return null;
                }

                setCachedText(file, textData) {
                    if (this.cache.size >= this.maxCacheSize) {
                        const oldestKey = this.cache.keys().next().value;
                        this.cache.delete(oldestKey);
                        console.log(' ç·©å­˜å·²æ»¿ï¼Œåˆªé™¤æœ€èˆŠæ¢ç›®');
                    }
                    const hash = this.generateFileHash(file);
                    const cacheEntry = {
                        timestamp: Date.now(),
                        data: textData
                    };
                    this.cache.set(hash, cacheEntry);
                    this.saveCacheToStorage();
                    console.log(` å·²ç·©å­˜PDFæ–‡å­—: ${file.name}`);
                }

                clearExpiredCache() {
                    const now = Date.now();
                    const expiredKeys = [];
                    
                    this.cache.forEach((value, key) => {
                        const daysSinceCached = (now - value.timestamp) / (1000 * 60 * 60 * 24);
                        if (daysSinceCached >= 7) {
                            expiredKeys.push(key);
                        }
                    });

                    expiredKeys.forEach(key => this.cache.delete(key));
                    if (expiredKeys.length > 0) {
                        this.saveCacheToStorage();
                        console.log(` æ¸…ç†äº† ${expiredKeys.length} å€‹éæœŸPDFç·©å­˜`);
                    }
                }

                getCacheStats() {
                    const totalSize = Array.from(this.cache.values())
                        .reduce((sum, entry) => sum + (entry.fileSize || 0), 0);
                    return {
                        count: this.cache.size,
                        totalSize: Math.round(totalSize / 1024), // KB
                        oldestCached: this.cache.size > 0 ? 
                            Math.min(...Array.from(this.cache.values()).map(e => e.timestamp)) : null
                    };
                }
            }

            // åˆå§‹åŒ–PDFç·©å­˜ç®¡ç†å™¨
            const pdfTextCache = new PDFTextCache();

            // Optional: transformer configuration loaded from localStorage
            const transformerConfig = {
                enabled: (localStorage.getItem('transformer_enabled') === 'true') || false,
                apiKey: localStorage.getItem('transformer_api_key') || '',
                provider: 'openai'
            };

            const PDF_PATHS = {
                en: './IFRS S1 EN.pdf',
                a: './IFRSS1_2023_A.pdf', 
                b: './IFRSS1_2023_B.pdf'
            };

            // Apply PDF.js configuration once it's ready
            function applyPdfJsConfiguration() {
                if (typeof window.pdfjsLib === 'undefined') {
                    console.warn('PDF.js å°šæœªè¼‰å…¥ï¼Œå»¶å¾Œå¥—ç”¨è¨­å®š');
                    return;
                }
                try {
                    const g = window.pdfjsLib.GlobalWorkerOptions;
                    if (!g.workerSrc || g.workerSrc === '') {
                        g.workerSrc = window.pdfWorkerSrcOverride || 'assets/pdfjs/pdf.worker.min.js';
                    }
                    g.disableFontFace = false;

                    // PDF document initialization parameters with Chinese support
                    window.pdfDocInitParams = {
                        // Enable CMap for Chinese character mapping
                        cMapUrl: './cmaps/',
                        cMapPacked: true,
                        
                        // Font and text rendering settings
                        useSystemFonts: true,
                        disableFontFace: false,
                        disableCreateObjectURL: false,
                        fontExtraProperties: true,
                        // Use local standard fonts to avoid remote fetch latency
                        standardFontDataUrl: './standard_fonts/',
                        
                        // Text layer options
                        isEvalSupported: false,
                        maxImageSize: -1,
                        useWorkerFetch: false,
                        stopAtErrors: false,
                        // Rendering optimizations
                        disableAutoFetch: true,
                        disableRange: true,
                        disableStream: true,
                        
                        // Set default font for Chinese characters
                        defaultFontFamily: 'Microsoft JhengHei, Microsoft YaHei, SimHei, SimSun, sans-serif',
                        
                        // Processing mode settings
                        verbosity: 0,
                        ignoreErrors: true,
                        
                        // Canvas rendering settings
                        useOnlyCssZoom: false,
                        maxCanvasPixels: 16777216
                    };
                    
                    // Monkey patch getDocument to inject init params
                    if (!window._originalPdfGetDocument && window.pdfjsLib.getDocument) {
                        window._originalPdfGetDocument = window.pdfjsLib.getDocument;
                        window.pdfjsLib.getDocument = function (src) {
                            const params = typeof src === 'string' ? { url: src } : { ...src };
                            return window._originalPdfGetDocument.call(this, { ...(window.pdfDocInitParams || {}), ...params });
                        };
                    }
                    console.log('âœ… å·²å¥—ç”¨ PDF.js é€²éšè¨­å®š');
                } catch (e) {
                    console.error('âŒ å¥—ç”¨ PDF.js è¨­å®šå¤±æ•—:', e);
                }
            }

            // è‹¥å·²å°±ç·’å‰‡ç«‹å³å¥—ç”¨ï¼Œå¦å‰‡ç­‰å¾…äº‹ä»¶
            if (window.pdfJsReady) {
                applyPdfJsConfiguration();
            }
            window.addEventListener('pdfjs-ready', applyPdfJsConfiguration);

            // Helper: wait until PDF.js is ready or disabled
            function waitForPdfJsReady(timeoutMs = 12000) {
                return new Promise((resolve, reject) => {
                    if (window.pdfJsDisabled) return resolve('disabled');
                    if (window.pdfjsLib && window.pdfJsReady) return resolve('ready');
                    const onReady = () => {
                        window.removeEventListener('pdfjs-ready', onReady);
                        resolve('ready');
                    };
                    window.addEventListener('pdfjs-ready', onReady);
                    const id = setTimeout(() => {
                        window.removeEventListener('pdfjs-ready', onReady);
                        reject(new Error('Timed out waiting for PDF.js'));
                    }, timeoutMs);
                });
            }

            // --- UI Element References ---
            const fileInput = document.getElementById('fileInput');
            const uploadZone = document.querySelector('.upload-zone');
            const loadingIndicator = document.getElementById('loadingIndicator');
            let statusElement = document.getElementById('status') || document.getElementById('preload-status');
            // å¦‚æœç‹€æ…‹å…ƒç´ ä¸å­˜åœ¨ï¼Œå‹•æ…‹å‰µå»ºä¸€å€‹ï¼Œé¿å…ç©ºå¼•ç”¨
            if (!statusElement && loadingIndicator) {
                const created = document.createElement('div');
                created.id = 'status';
                created.style.marginTop = '10px';
                created.textContent = '';
                loadingIndicator.appendChild(created);
                statusElement = created;
            }
            // è¨­ç½®å…¨å±€è®Šé‡ä»¥ä¾¿ä¸‹è¼‰å‡½æ•¸ä½¿ç”¨
            window.statusElement = statusElement;

            // --- Multi-stage Progress Bar Logic ---
            const progressStages = {
                pdf: { bar: document.querySelector('#stage-pdf .progress-bar-inner'), status: document.querySelector('#stage-pdf .progress-stage-status'), el: document.getElementById('stage-pdf') },
                analysis: { bar: document.querySelector('#stage-analysis .progress-bar-inner'), status: document.querySelector('#stage-analysis .progress-stage-status'), el: document.getElementById('stage-analysis') },
                report: { bar: document.querySelector('#stage-report .progress-bar-inner'), status: document.querySelector('#stage-report .progress-stage-status'), el: document.getElementById('stage-report') }
            };
            const overallStatusEl = document.getElementById('overall-status');

            function updateProgress(stage, percentage, statusText) {
                if (progressStages[stage]) {
                    progressStages[stage].bar.style.width = `${percentage}%`;
                    progressStages[stage].status.textContent = statusText;

                    if (percentage > 0 && percentage < 100) {
                        progressStages[stage].el.classList.add('active');
                        progressStages[stage].el.classList.remove('completed');
                    } else if (percentage === 100) {
                        progressStages[stage].el.classList.remove('active');
                        progressStages[stage].el.classList.add('completed');
                    }
                }
            }

            function resetProgress() {
                Object.values(progressStages).forEach(stage => {
                    stage.bar.style.width = '0%';
                    stage.status.textContent = 'å¾…è™•ç†';
                    stage.el.classList.remove('active', 'completed');
                });
                overallStatusEl.textContent = 'æ­£åœ¨åˆå§‹åŒ–...';
            }
            const reportContainer = document.getElementById('reportContainer');

            // --- Initialization ---
            function initializeIFRSData() {
                console.log('[DEBUG] Initializing IFRS S1 data...');
                try {
                    if (typeof IFRS_S1_COMPLETE_ARTICLES !== 'undefined' && Array.isArray(IFRS_S1_COMPLETE_ARTICLES)) {
                        ifrs1Data.articles = IFRS_S1_COMPLETE_ARTICLES;
                        console.log(`[SUCCESS] Loaded ${ifrs1Data.articles.length} articles.`);
                    } else {
                        throw new Error('External IFRS article data not found or invalid.');
                    }
                } catch (error) {
                    console.error('[ERROR] Failed to load IFRS articles:', error.message);
                    alert('ç„¡æ³•åŠ è¼‰IFRS S1æ¢æ–‡æ•¸æ“šï¼Œéƒ¨åˆ†åŠŸèƒ½å¯èƒ½ç„¡æ³•æ­£å¸¸é‹ä½œã€‚');
                }
            }

            // --- Utility functions for concept-based matching ---
            function normalizeText(t) {
                return (t || '').toLowerCase();
            }

            function tokenize(text) {
                const t = normalizeText(text);
                // Han chars or alphanumerics
                const m = t.match(/[\p{Script=Han}]+|[a-z0-9]+/gu);
                return m || [];
            }

            const STOPWORDS = new Set(['çš„','å’Œ','èˆ‡','æˆ–','åŠ','åœ¨','å°','ç‚º','æ˜¯','åŠå…¶','ä¸¦','ç­‰','èˆ‡å…¶','ä»¥åŠ','åŒ…æ‹¬','æˆ–æ˜¯','å¦‚æœ','æ‡‰','éœ€','å¯èƒ½','å› æ­¤','æœ¬','è©²','å…¶','å…¬å¸','ä¼æ¥­','the','and','of','to','in','for','on','with','by','as','is','are','be','that','this','an','a','at','from','it','its','or','not','may','should','must','can','could','would','will']);

            function extractCoreConceptTokens(article, maxTokens = 12) {
                const source = [article.title, article.content].filter(Boolean).join(' ');
                const toks = tokenize(source).filter(tok => !STOPWORDS.has(tok) && tok.length > 1);
                const freq = new Map();
                toks.forEach(tok => freq.set(tok, (freq.get(tok) || 0) + 1));
                const sorted = [...freq.entries()].sort((a,b) => b[1]-a[1]).map(([k]) => k);
                // Always include keywords
                const kws = Array.isArray(article.keywords) ? article.keywords.map(k => normalizeText(k)) : [];
                const set = new Set([...(sorted.slice(0, maxTokens)), ...kws.filter(k => k && !STOPWORDS.has(k))]);
                return [...set];
            }

            function jaccard(aArr, bArr) {
                const a = new Set(aArr);
                const b = new Set(bArr);
                let inter = 0;
                a.forEach(x => { if (b.has(x)) inter++; });
                const union = a.size + b.size - inter;
                return union === 0 ? 0 : inter / union;
            }

            function detectLanguage(text) {
                const tokens = tokenize(text);
                const englishTokens = tokens.filter(t => /^[a-zA-Z]+$/.test(t));
                return englishTokens.length / tokens.length > 0.5;
            }

            // å…§å®¹éæ¿¾æ©Ÿåˆ¶ï¼šæ’é™¤ç›®æ¬¡ã€é‡è¤‡æ¨™é¡Œã€é ç¢¼ç­‰ç„¡æ•ˆå…§å®¹
            function isInvalidContent(sentence) {
                if (!sentence || sentence.length < 10) return true;
                
                // ç›®æ¬¡/ç›®éŒ„æ¨¡å¼è­˜åˆ¥
                const tocPatterns = [
                    /^ç¬¬[ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹å\d]+ç« \s*[\.\s]*\d*$/,          // ç« ç¯€ç›®éŒ„
                    /^ç¬¬[ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹å\d]+ç¯€\s*[\.\s]*\d*$/,          // ç¯€ç›®éŒ„
                    /^\d+[\.\s]+[\u4e00-\u9fff\w\s]+[\.\s]*\d+\s*$/,        // ç·¨è™Ÿ+æ¨™é¡Œ+é ç¢¼
                    /^[\u4e00-\u9fff\w\s]+[\.\s]+\d+\s*$/,                  // æ¨™é¡Œ+é ç¢¼
                    /^[\.\s]*\d+[\.\s]*$/,                                   // ç´”é ç¢¼
                    /^ç›®\s*æ¬¡|ç›®\s*éŒ„|å…§\s*å®¹/,                             // ç›®æ¬¡/ç›®éŒ„/å…§å®¹
                    /^æ‘˜\s*è¦|åº\s*è¨€|å‰\s*è¨€|é™„\s*éŒ„/                       // æ‘˜è¦ã€åºè¨€ç­‰
                ];
                
                if (tocPatterns.some(pattern => pattern.test(sentence.trim()))) {
                    console.log('éæ¿¾ç›®æ¬¡å…§å®¹:', sentence.substring(0, 50));
                    return true;
                }
                
                // é‡è¤‡æ¨™é¡Œæª¢æ¸¬ï¼ˆç°¡åŒ–ç‰ˆï¼šæª¢æ¸¬éçŸ­çš„é‡è¤‡æ€§æ–‡æœ¬ï¼‰
                if (sentence.length < 20 && /^[\u4e00-\u9fff\w\s]{1,15}$/.test(sentence)) {
                    const words = sentence.split(/\s+/).filter(w => w.length > 1);
                    if (words.length <= 3) {
                        console.log('éæ¿¾ç–‘ä¼¼é‡è¤‡æ¨™é¡Œ:', sentence);
                        return true;
                    }
                }
                
                // é çœ‰é è…³æ¨¡å¼
                const headerFooterPatterns = [
                    /^ç¬¬\s*\d+\s*é /,                                        // ç¬¬Xé 
                    /é \s*\d+\s*$/,                                          // é X
                    /^\d{4}å¹´\d{1,2}æœˆ/,                                     // æ—¥æœŸæ ¼å¼
                    /^ç‰ˆæ¬Šæ‰€æœ‰|Â©|Copyright/i,                                // ç‰ˆæ¬Šè²æ˜
                    /^[\-=\s]*$/                                             // åˆ†éš”ç·š
                ];
                
                if (headerFooterPatterns.some(pattern => pattern.test(sentence.trim()))) {
                    console.log('éæ¿¾é çœ‰é è…³:', sentence.substring(0, 30));
                    return true;
                }
                
                // éçŸ­æˆ–éé•·çš„ç„¡æ•ˆå…§å®¹
                if (sentence.length < 15 || sentence.length > 1000) {
                    return true;
                }
                
                // æ•¸å­—å¯†åº¦éé«˜ï¼ˆå¯èƒ½æ˜¯è¡¨æ ¼æ•¸æ“šï¼‰
                const numbers = sentence.match(/\d/g) || [];
                if (numbers.length / sentence.length > 0.3) {
                    console.log('éæ¿¾æ•¸å­—å¯†åº¦éé«˜:', sentence.substring(0, 50));
                    return true;
                }
                
                return false;
            }

            function scoreSentence(sentence, coreTokens, keywordSet) {
                const toks = tokenize(sentence);
                let coreHit = 0;
                let kwHit = 0;
                const matchedCore = [];
                const sentenceTokens = new Set(toks);

                // Check core concept matches
                for (const coreToken of coreTokens) {
                    if (sentenceTokens.has(coreToken)) {
                        coreHit++;
                        matchedCore.push(coreToken);
                    }
                }

                // Check keyword matches
                for (const token of toks) {
                    if (keywordSet.has(token)) {
                        kwHit++;
                    }
                }

                return { coreHit, kwHit, matchedCore, toks };
            }

            async function generateAIReasoning(article, sentence, page, matchedCore, unmatchedCore, simScore) {
                // ç›´æ¥ä½¿ç”¨æœ¬åœ°å‹•æ…‹ç”Ÿæˆ
                return generateDynamicReasoning(article, sentence, page, matchedCore, unmatchedCore, simScore);
            }
            
            async function generateTransformerReasoning(article, sentence, page, matchedCore, unmatchedCore) {
                if (!transformerConfig.enabled || !transformerConfig.apiKey) return null;
                try {
                    const matchedCoreText = matchedCore.slice(0, 5).join('ã€');
                    const unmatchedCoreText = unmatchedCore.slice(0, 5).join('ã€');

                    const prompt = `èº«ç‚ºè³‡æ·±ä¼æ¥­æ°¸çºŒç™¼å±•é¡§å•ï¼Œè«‹åˆ†æä»¥ä¸‹å…§å®¹ï¼š

æ¢æ–‡ï¼š${article.id} ${article.title}
æ¢æ–‡å…§å®¹æ‘˜è¦ï¼š${(article.content || '').slice(0, 400)}

å€™é¸è­‰æ“šï¼ˆç¬¬${page}é ï¼‰ï¼š${sentence}

å·²åŒ¹é…æ ¸å¿ƒæ¦‚å¿µï¼š${matchedCoreText || 'ç„¡'}
æœªåŒ¹é…æ ¸å¿ƒæ¦‚å¿µï¼š${unmatchedCoreText || 'ç„¡'}

è«‹ä»¥å°ˆæ¥­å•†æ¥­é¡§å•çš„è¦–è§’åˆ†æï¼š
1. æ­¤è­‰æ“šèˆ‡æ¢æ–‡çš„æ ¸å¿ƒæ¦‚å¿µé—œè¯æ€§
2. å…±åŒé»ï¼šå¥å­èˆ‡æ¢æ–‡åœ¨å•†æ¥­é‚è¼¯ä¸Šçš„å°é½Šç¨‹åº¦
3. å·®ç•°é»ï¼šå¥å­ç›¸å°æ–¼æ¢æ–‡æ¨™æº–çš„ä¸è¶³ä¹‹è™•
4. æ•´é«”è©•ä¼°ï¼šæ­¤è­‰æ“šçš„è­‰æ˜åŠ›å¼·åº¦

è«‹ç”¨ç¹é«”ä¸­æ–‡æä¾›ç²¾ç°¡ä½†æ·±å…¥çš„åˆ†æï¼Œç›´æ¥é€²å…¥åˆ†æå…§å®¹ï¼Œä¸è¦æœ‰é–‹å ´ç™½ã€‚`;

                    const body = {
                        model: 'gpt-4o-mini',
                        messages: [
                            { role: 'system', content: 'ä½ æ˜¯è³‡æ·±ä¼æ¥­æ°¸çºŒç™¼å±•é¡§å•ï¼Œå°ˆç²¾IFRS S1æ¢æ–‡åˆ†æèˆ‡ä¼æ¥­å¯¦å‹™æ‡‰ç”¨ã€‚ä½ éœ€è¦æä¾›å°ˆæ¥­ã€å®¢è§€çš„å•†æ¥­åˆ†æè¦‹è¦‹ã€‚' },
                            { role: 'user', content: prompt }
                        ],
                        temperature: 0.3,
                        max_tokens: 300
                    };

                    // Ensure proper UTF-8 encoding for Chinese characters
                    const resp = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json; charset=utf-8',
                            'Authorization': `Bearer ${transformerConfig.apiKey}`
                        },
                        body: JSON.stringify(body)
                    });

                    if (!resp.ok) {
                        throw new Error(`API request failed: ${resp.status}`);
                    }

                    const data = await resp.json();
                    let text = data?.choices?.[0]?.message?.content?.trim();

                    // Ensure proper UTF-8 decoding of Chinese characters
                    if (text) {
                        // Decode any potential encoding issues
                        text = decodeURIComponent(encodeURIComponent(text));
                        // Ensure it's properly encoded for HTML display
                        text = text.replace(/[\u00A0-\u9999<>\&]/g, function(i) {
                            return '&#'+i.charCodeAt(0)+';';
                        }).replace(/&#60;/g, '&lt;').replace(/&#62;/g, '&gt;').replace(/&#38;/g, '&amp;');
                    }

                    return text || null;
                } catch (e) {
                    console.warn('[WARN] Transformer reasoning failed:', e);
                    return null;
                }
            }

            function generateDynamicReasoning(article, sentence, page, matchedCore, unmatchedCore, simScore) {
                // å¢å¼·ç‰ˆå‹•æ…‹ç”Ÿæˆè­‰æ“šè§£é‡‹ï¼Œåˆ©ç”¨æ¢æ–‡çš„è±å¯Œä¸Šä¸‹æ–‡è³‡è¨Š
                const coreMatches = matchedCore.length;
                const semanticStrength = simScore;
                
                // ç²å–æ¢æ–‡çš„æ“´å……è³‡è¨Š
                const articleCategory = article.category || 'ä¸€èˆ¬æ¢æ–‡';
                const articleDifficulty = article.difficulty || 'medium';
                const practicalGuidance = article.practical_guidance || '';
                const relatedStandards = article.related_standards || [];
                
                // æ ¹æ“šæ¢æ–‡é¡åˆ¥èª¿æ•´åˆ†æè§’åº¦
                const categoryContext = {
                    'æ²»ç†': {
                        focus: 'æ²»ç†æ¶æ§‹èˆ‡è²¬ä»»åˆ†å·¥',
                        keywords: ['è‘£äº‹æœƒ', 'ç®¡ç†éšå±¤', 'å§”å“¡æœƒ', 'è·è²¬', 'ç›£ç£'],
                        emphasis: 'çµ„ç¹”å±¤é¢çš„æ°¸çºŒæ²»ç†æ©Ÿåˆ¶'
                    },
                    'ç­–ç•¥': {
                        focus: 'ç­–ç•¥è¦åŠƒèˆ‡åŸ·è¡Œ',
                        keywords: ['ç­–ç•¥', 'ç›®æ¨™', 'è¨ˆåŠƒ', 'è³‡æº', 'åŸ·è¡Œ'],
                        emphasis: 'ä¼æ¥­æ°¸çºŒç­–ç•¥çš„åˆ¶å®šèˆ‡å¯¦æ–½'
                    },
                    'é¢¨éšªç®¡ç†': {
                        focus: 'é¢¨éšªè­˜åˆ¥èˆ‡ç®¡æ§',
                        keywords: ['é¢¨éšª', 'è­˜åˆ¥', 'è©•ä¼°', 'ç®¡æ§', 'ç·©è§£'],
                        emphasis: 'æ°¸çºŒé¢¨éšªçš„ç³»çµ±æ€§ç®¡ç†'
                    },
                    'æŒ‡æ¨™èˆ‡ç›®æ¨™': {
                        focus: 'é‡åŒ–æŒ‡æ¨™èˆ‡ç›®æ¨™è¨­å®š',
                        keywords: ['æŒ‡æ¨™', 'ç›®æ¨™', 'é‡åŒ–', 'ç›£æ§', 'ç¸¾æ•ˆ'],
                        emphasis: 'å¯é‡åŒ–çš„æ°¸çºŒç¸¾æ•ˆç®¡ç†'
                    },
                    'å ±å‘ŠåŸºç¤': {
                        focus: 'è³‡è¨Šæ­éœ²èˆ‡å ±å‘Šå“è³ª',
                        keywords: ['æ­éœ²', 'å ±å‘Š', 'è³‡è¨Š', 'é€æ˜', 'å“è³ª'],
                        emphasis: 'æ°¸çºŒè³‡è¨Šçš„æœ‰æ•ˆå‚³é”'
                    }
                };
                
                const currentContext = categoryContext[articleCategory] || categoryContext['å ±å‘ŠåŸºç¤'];
                
                // æ ¹æ“šæ¢æ–‡é›£åº¦èª¿æ•´è©•ä¼°æ¨™æº–
                let difficultyThresholds = { high: 0.20, medium: 0.12, low: 0.08 };
                if (articleDifficulty === 'high') difficultyThresholds = { high: 0.25, medium: 0.15, low: 0.10 };
                if (articleDifficulty === 'low') difficultyThresholds = { high: 0.15, medium: 0.08, low: 0.05 };
                
                // å‹•æ…‹é¸æ“‡å¼·åº¦ç­‰ç´šï¼ˆè€ƒæ…®æ¢æ–‡é›£åº¦ï¼‰
                let strengthLevel = 'low';
                if (coreMatches >= 3 && semanticStrength >= difficultyThresholds.high) strengthLevel = 'high';
                else if (coreMatches >= 2 || semanticStrength >= difficultyThresholds.medium) strengthLevel = 'medium';
                
                // å¤šæ¨£åŒ–çš„å¼·åº¦æè¿°
                const strengthDescriptors = {
                    high: ['å……åˆ†é«”ç¾', 'æ˜ç¢ºåæ˜ ', 'æ·±åº¦å¥‘åˆ', 'å…¨é¢æ¶µè“‹', 'å…·é«”è½å¯¦'],
                    medium: ['éƒ¨åˆ†é«”ç¾', 'é©åº¦åæ˜ ', 'åŸºæœ¬ç¬¦åˆ', 'å±€éƒ¨æ¶µè“‹', 'åˆæ­¥å±•ç¾'],
                    low: ['ç•¥æœ‰æåŠ', 'é–“æ¥æ¶‰åŠ', 'éš±ç´„ç›¸é—œ', 'æœ‰é™åæ˜ ', 'é›¶æ˜Ÿæ¶‰åŠ']
                };
                
                const strengthVerb = strengthDescriptors[strengthLevel][Math.floor(Math.random() * strengthDescriptors[strengthLevel].length)];
                
                // å¢å¼·ç‰ˆæ¨¡æ¿ï¼Œçµåˆæ¢æ–‡é¡åˆ¥ç‰¹æ€§
                const templates = [
                    // é¡åˆ¥å°å‘åˆ†æå‹
                    () => `å¾${currentContext.focus}çš„è§’åº¦åˆ†æï¼Œæ­¤æ®µå…§å®¹${strengthVerb}äº†${article.title}åœ¨${currentContext.emphasis}æ–¹é¢çš„è¦æ±‚ã€‚æ–‡ä¸­${matchedCore.slice(0, 2).join('èˆ‡')}ç­‰æ¦‚å¿µèˆ‡æ¢æ–‡æ ¸å¿ƒ${strengthLevel === 'high' ? 'é«˜åº¦å»åˆ' : strengthLevel === 'medium' ? 'åŸºæœ¬å°æ‡‰' : 'éƒ¨åˆ†ç›¸é—œ'}ã€‚`,
                    
                    // å¯¦å‹™æŒ‡å¼•æ•´åˆå‹
                    () => `ä¾æ“šIFRS S1å¯¦å‹™æŒ‡å¼•ï¼Œè©²è­‰æ“šåœ¨${currentContext.focus}å±¤é¢${strengthVerb}ç›¸é—œè¦æ±‚ã€‚${practicalGuidance ? 'ç‰¹åˆ¥æ˜¯åœ¨' + practicalGuidance.slice(0, 50) + 'ç­‰æ–¹é¢ï¼Œ' : ''}èªç¾©ç›¸ä¼¼åº¦${(semanticStrength * 100).toFixed(1)}%é¡¯ç¤º${strengthLevel === 'high' ? 'å¼·åŠ›æ”¯æ’' : strengthLevel === 'medium' ? 'é©åº¦ä½è­‰' : 'åˆæ­¥å°è­‰'}ã€‚`,
                    
                    // æ¢æ–‡é—œè¯å‹
                    () => `æ­¤è­‰æ“šèˆ‡${article.title}è¦æ±‚çš„åŒ¹é…åº¦ç‚º${(semanticStrength * 100).toFixed(1)}%ã€‚${relatedStandards.length > 0 ? `çµåˆç›¸é—œæ¢æ–‡${relatedStandards.slice(0, 2).join('ã€')}çš„è¦æ±‚ï¼Œ` : ''}è©²å…§å®¹åœ¨${currentContext.emphasis}æ–¹é¢${strengthLevel === 'high' ? 'æä¾›äº†å……åˆ†çš„è­‰æ˜' : strengthLevel === 'medium' ? 'çµ¦å‡ºäº†åˆç†çš„èªªæ˜' : 'å±•ç¾äº†åŸºæœ¬çš„èªçŸ¥'}ã€‚`,
                    
                    // é›£åº¦èª¿æ•´å‹  
                    () => `è€ƒé‡${article.title}å±¬${articleDifficulty === 'high' ? 'é«˜' : articleDifficulty === 'medium' ? 'ä¸­' : 'ä½'}è¤‡é›œåº¦æ¢æ–‡ï¼Œæ­¤è­‰æ“š${strengthVerb}äº†æ ¸å¿ƒè¦æ±‚ã€‚åœ¨${matchedCore.slice(0, 2).join('èˆ‡')}ç­‰${currentContext.keywords.filter(k => matchedCore.some(m => m.includes(k))).join('ã€')}é—œéµé¢å‘ä¸Šï¼Œ${strengthLevel === 'high' ? 'é”åˆ°äº†é æœŸæ¨™æº–' : strengthLevel === 'medium' ? 'ç¬¦åˆåŸºæœ¬è¦æ±‚' : 'å±•ç¾äº†åˆæ­¥æˆæ•ˆ'}ã€‚`
                ];
                
                // éš¨æ©Ÿé¸æ“‡æ¨¡æ¿ä¸¦åŸ·è¡Œ
                const selectedTemplate = templates[Math.floor(Math.random() * templates.length)];
                return selectedTemplate();
            }

            // Utility: timeout wrapper to avoid hanging promises
            function withTimeout(promise, ms = 15000) {
                return new Promise((resolve, reject) => {
                    const timer = setTimeout(() => {
                        reject(new Error(`Operation timed out after ${ms}ms`));
                    }, ms);
                    promise.then((val) => { clearTimeout(timer); resolve(val); })
                           .catch((err) => { clearTimeout(timer); reject(err); });
                });
            }

            // Utility: fetch with timeout using AbortController
            function fetchWithTimeout(resource, options = {}, timeout = 8000) {
                const controller = new AbortController();
                const id = setTimeout(() => controller.abort(), timeout);
                return fetch(resource, { ...options, signal: controller.signal })
                    .finally(() => clearTimeout(id));
            }

            async function preloadPDFFiles() {
                if (!window.pdfjsLib || !window.pdfJsReady) {
                    console.log(' ç•¥éPDFé è¼‰ï¼ˆPDF.js æœªå°±ç·’æˆ–å·²ç¦ç”¨ï¼‰');
                    Object.keys(PDF_PATHS).forEach((lang) => {
                        const el = document.getElementById(`status-${lang}`);
                        if (el) el.textContent = window.pdfJsDisabled ? 'PDFåŠŸèƒ½å·²ç¦ç”¨' : 'Skipped';
                    });
                    return;
                }
                const pdfPromises = Object.keys(PDF_PATHS).map(async (lang) => {
                    const path = PDF_PATHS[lang];
                    const statusUI = document.getElementById(`status-${lang}`);
                    try {
                        if (statusUI) statusUI.textContent = 'Loading...';
                        // Ensure URL is properly encoded to handle spaces and non-ASCII characters
                        const encodedUrl = encodeURI(path);
                        const loadingTask = pdfjsLib.getDocument({ url: encodedUrl, ...(window.pdfDocInitParams || {}) }).promise;
                        preloadedPDFFiles[lang] = await withTimeout(loadingTask, 20000);
                        if (statusUI) {
                            statusUI.textContent = 'Loaded';
                            statusUI.style.color = 'green';
                        }
                        console.log(`[SUCCESS] Preloaded ${path}`);
                    } catch (err) {
                        if (statusUI) {
                            const isMissing = err && (err.name === 'MissingPDFException' || (typeof err.message === 'string' && err.message.includes('Missing PDF')));
                            statusUI.textContent = isMissing ? 'Not Found' : 'Failed';
                            statusUI.style.color = isMissing ? 'orange' : 'red';
                        }
                        console.error(`[ERROR] Failed to preload ${path}:`, err);
                    }
                });
                await Promise.all(pdfPromises);
                console.log('[INFO] PDF preloading complete.');
            }

            // --- File Handling ---
            // uploadZone.addEventListener('click', () => fileInput.click()); // Removed to prevent double popup
            fileInput.addEventListener('change', (e) => handleFileSelect(e.target.files));
            
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                uploadZone.addEventListener(eventName, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (['dragenter', 'dragover'].includes(eventName)) {
                        uploadZone.classList.add('dragover');
                    } else {
                        uploadZone.classList.remove('dragover');
                    }
                }, false);
            });

            uploadZone.addEventListener('drop', (e) => handleFileSelect(e.dataTransfer.files), false);

            async function handleFileSelect(files) {
                if (files.length > 0) {
                    const file = files[0];
                    if (file.type === 'application/pdf') {
                        handleFileUpload(file);
                    } else {
                        alert('è«‹ä¸Šå‚³æœ‰æ•ˆçš„PDFæ–‡ä»¶ã€‚');
                    }
                }
            }

            async function handleFileUpload(file) {
                console.log(`[INFO] File selected: ${file.name}`);

                // Hide hardware status to show file progress
                const hardwareStatus = document.getElementById('hardware-acceleration-status');
                if (hardwareStatus) {
                    hardwareStatus.style.display = 'none';
                }

                // Validate file size (max 50MB)
                const maxFileSize = 50 * 1024 * 1024; // 50MB
                if (file.size > maxFileSize) {
                    alert('æª”æ¡ˆå¤§å°è¶…é50MBé™åˆ¶ï¼Œè«‹é¸æ“‡è¼ƒå°çš„PDFæ–‡ä»¶ã€‚');
                    return;
                }

                loadingIndicator.style.display = 'block';
                reportContainer.innerHTML = '';
                resetProgress();
                updateProgress('pdf', 5, 'æ­£åœ¨è®€å–æ–‡ä»¶...');
                overallStatusEl.textContent = 'æ­¥é©Ÿ 1/3: è§£æ PDF æ–‡ä»¶';

                //  æª¢æŸ¥PDFæ–‡å­—ç·©å­˜
                const cachedText = pdfTextCache.getCachedText(file);
                if (cachedText && cachedText.data) {
                    console.log(' ä½¿ç”¨PDFæ–‡å­—ç·©å­˜ï¼Œè·³éæå–æ­¥é©Ÿ');
                    const textData = cachedText.data;
                    const fakePdf = { 
                        numPages: textData.pages.length, 
                        getPage: async (i) => ({ 
                            getTextContent: async () => ({ 
                                items: textData.pages[i-1].map(t => ({str: t})) 
                            }) 
                        }) 
                    };
                    performComprehensiveAnalysis(fakePdf, file.name);
                    return;
                }

                // Ensure PDF.js is ready before attempting to parse
                try {
                    const state = await waitForPdfJsReady(12000);
                    if (state === 'disabled') {
                        throw new Error('PDF.js disabled');
                    }
                } catch (e) {
                    console.error('[ERROR] PDF.js not ready:', e);
                    loadingIndicator.style.display = 'none';
                    alert('PDF åŠŸèƒ½ç›®å‰ä¸å¯ç”¨ï¼ˆPDF.js æœªè¼‰å…¥æˆåŠŸï¼‰ã€‚è«‹ç¨å¾Œå†è©¦æˆ–æª¢æŸ¥ç¶²è·¯ã€‚');
                    return;
                }

                const fileReader = new FileReader();
                fileReader.onload = async (event) => {
                    try {
                        const pdfData = new Uint8Array(event.target.result);
                        if (!window.pdfjsLib) {
                            throw new Error('pdfjsLib is not available');
                        }
                        const loadingTask = pdfjsLib.getDocument({ data: pdfData, ...(window.pdfDocInitParams || {}) });
                        const pdf = await loadingTask.promise;
                        console.log('PDF loaded successfully');
                        await performComprehensiveAnalysis(pdf, file.name);
                    } catch (error) {
                        console.error('[ERROR] PDF parsing failed:', error);
                        loadingIndicator.style.display = 'none';
                        let errorMessage = 'PDFæ–‡ä»¶è§£æå¤±æ•—';
                        if (error.name === 'InvalidPDFException') {
                            errorMessage = 'é€™ä¸æ˜¯æœ‰æ•ˆçš„PDFæ–‡ä»¶ï¼Œè«‹æª¢æŸ¥æª”æ¡ˆæ ¼å¼ã€‚';
                        } else if (error.name === 'PasswordException') {
                            errorMessage = 'PDFæ–‡ä»¶å·²åŠ å¯†ï¼Œè«‹æä¾›æœªåŠ å¯†çš„PDFæ–‡ä»¶ã€‚';
                        } else if (error.message.includes('CORS')) {
                            errorMessage = 'PDFæ–‡ä»¶è¼‰å…¥å—é™ï¼Œè«‹ç¢ºä¿æª”æ¡ˆæœªæå£ã€‚';
                        }
                        alert(`${errorMessage}: ${error.message}`);
                    }
                };

                fileReader.onerror = () => {
                    console.error('[ERROR] File reading failed');
                    loadingIndicator.style.display = 'none';
                    alert('æª”æ¡ˆè®€å–å¤±æ•—ï¼Œè«‹æª¢æŸ¥æª”æ¡ˆæ˜¯å¦æå£æˆ–é‡æ–°ä¸Šå‚³ã€‚');
                };

                fileReader.onprogress = (e) => {
                    if (e.lengthComputable) {
                        const percentComplete = (e.loaded / e.total) * 100;
                        updateProgress('pdf', 5 + (percentComplete * 0.1), `æ­£åœ¨è®€å–æª”æ¡ˆ... ${Math.round(percentComplete)}%`);
                    }
                };

                fileReader.readAsArrayBuffer(file);
            }

            // --- Analysis Pipeline ---
            async function performComprehensiveAnalysis(pdf, fileName) {
                statusElement.textContent = 'æ­£åœ¨å¾PDFæå–æ–‡å­—...';
                let allText = '';
                const totalPages = pdf.numPages;
                sentencesByPage = [];
                paragraphsByPage = [];

                for (let i = 1; i <= totalPages; i++) {
                    try {
                        const page = await pdf.getPage(i);
                        // Use enhanced text extraction with proper text layer handling
                        const textContent = await page.getTextContent({
                            normalizeWhitespace: true,
                            disableCombineTextItems: false  // Keep text items combined for better Chinese character handling
                        });
                        
                        // Improved text extraction with better Chinese character handling
                        const pageText = (textContent.items || [])
                            .map(item => {
                                // Preserve Chinese punctuation and characters
                                let text = (item.str || '').replace(/[\u200b-\u200f\ufeff]/g, ''); // Remove zero-width spaces
                                // Normalize Chinese punctuations and spaces
                                text = text.replace(/[\s\u3000]+/g, ' ').trim(); // Convert full-width spaces to half-width
                                return text;
                            })
                            .filter(Boolean)
                            .join(' ')
                            .replace(/\s+/g, ' ');
                            
                        allText += pageText + '\n';
                        
                        // Enhanced Chinese text segmentation
                        const sentences = [];
                        // Split by Chinese and English sentence terminators
                        const sentenceRegex = /[^ã€‚ï¼ï¼Ÿ!?\n]+([ã€‚ï¼ï¼Ÿ!?\n]|$)/g;
                        let match;
                        while ((match = sentenceRegex.exec(pageText)) !== null) {
                            const sentence = match[0].trim();
                            if (sentence && !isInvalidContent(sentence)) {
                                sentences.push(sentence);
                            }
                        }
                        
                        // Create paragraphs by grouping sentences (5-8 sentences per paragraph with sliding window)
                        const paragraphs = [];
                        const paragraphSize = Math.min(8, Math.max(5, Math.ceil(sentences.length / 10))); // å‹•æ…‹èª¿æ•´æ®µè½å¤§å°
                        
                        // ä¸»è¦æ®µè½ï¼š5-8å¥ç‚ºä¸€æ®µ
                        for (let i = 0; i < sentences.length; i += paragraphSize) {
                            const paragraph = sentences.slice(i, i + paragraphSize).join(' ');
                            if (paragraph && paragraph.length > 50) { // ç¢ºä¿æ®µè½æœ‰è¶³å¤ å…§å®¹
                                paragraphs.push(paragraph);
                            }
                        }
                        
                        // æ»‘å‹•çª—å£æ®µè½ï¼šé‡ç–Šåˆ†æç¢ºä¿èªç¾©é€£è²«æ€§
                        if (sentences.length > paragraphSize) {
                            const overlapSize = Math.floor(paragraphSize / 2);
                            for (let i = overlapSize; i < sentences.length - paragraphSize; i += paragraphSize) {
                                const overlapParagraph = sentences.slice(i, i + paragraphSize).join(' ');
                                if (overlapParagraph && overlapParagraph.length > 50) {
                                    paragraphs.push(overlapParagraph);
                                }
                            }
                        }
                        sentencesByPage.push({ page: i, sentences });
                        paragraphsByPage.push({ page: i, paragraphs });

                        const progress = 15 + ((i / totalPages) * 85);
                        updateProgress('pdf', progress, `æ­£åœ¨è§£æ ${i} / ${totalPages} é `);

                    } catch (pageError) {
                        console.warn(`Could not extract text from page ${i}:`, pageError);
                    }
                }

                if (!allText.trim()) {
                    alert('PDFæ–‡å­—å…§å®¹ç‚ºç©ºæˆ–ç„¡æ³•æå–ï¼Œç„¡æ³•é€²è¡Œåˆ†æã€‚');
                    loadingIndicator.style.display = 'none';
                    return;
                }

                //  ä¿å­˜æå–çš„æ–‡æœ¬åˆ°ç·©å­˜ 
                const textData = {
                    totalPages,
                    sentencesByPage,
                    paragraphsByPage,
                    extractedText: allText
                };
                
                // éœ€è¦ç²å–ç•¶å‰æ–‡ä»¶å°è±¡ä¾†ä¿å­˜ç·©å­˜ï¼Œä½¿ç”¨å…¨å±€è®Šé‡å­˜å„²
                if (window.currentProcessingFile) {
                    pdfTextCache.setCachedText(window.currentProcessingFile, textData);
                }

                updateProgress('pdf', 100, 'è§£æå®Œæˆ');
                overallStatusEl.textContent = 'æ­¥é©Ÿ 2/3: é€²è¡Œèªç¾©åˆ†æ';
                updateProgress('analysis', 5, 'æº–å‚™æ¯”å°...');

                const isEnglish = detectLanguage(allText);
                await performAIAnalysis(allText, fileName, totalPages, isEnglish);
            }

            // === æœ¬åœ°èªç¾©åˆ†ææ¨¡çµ„ ===
            class LocalSemanticAnalyzer {
                constructor() {
                    this.models = null;
                    this.preprocessor = null;
                    this.isInitialized = false;
                }

                async initializeModels() {
                    if (this.isInitialized) return;
                    
                    try {
                        console.log('åˆå§‹åŒ–æœ¬åœ°èªç¾©åˆ†ææ¨¡å‹...');
                        
                        // æª¢æŸ¥æ˜¯å¦æœ‰å¯ç”¨çš„æ¨¡å‹æœå‹™
                        const response = await fetchWithTimeout('http://localhost:8002/health', {
                            method: 'GET',
                            cache: 'no-store'
                        }, 6000);
                        
                        if (response.ok) {
                            const healthData = await response.json();
                            console.log(`æœ¬åœ°æ¨¡å‹æœå‹™å¯ç”¨: ${healthData.service_type}`);
                            this.isInitialized = true;
                        } else {
                            throw new Error('Local model service not available');
                        }
                    } catch (error) {
                        console.warn('æœ¬åœ°æ¨¡å‹æœå‹™ä¸å¯ç”¨ï¼Œå°‡ä½¿ç”¨é›¢ç·šæ¨¡å¼:', error);
                        this.isInitialized = false;
                    }
                }

                // è¡“èªæ¨™æº–åŒ–å­—å…¸
                getTerminologyDict() {
                    return {
                        'æ°£å€™è®Šé·': 'æ°£å€™è®ŠåŒ–',
                        'æ°£å€™è®Šå‹•': 'æ°£å€™è®ŠåŒ–',
                        'å…¨çƒæš–åŒ–': 'å…¨çƒè®Šæš–',
                        'æº«å®¤æ°£é«”': 'GHG',
                        'ç¢³æ’æ”¾': 'æº«å®¤æ°£é«”æ’æ”¾',
                        'ç¢³è¶³è·¡': 'ç¢³æ’æ”¾é‡',
                        'é¢¨éšªè©•ä¼°': 'é¢¨éšªè­˜åˆ¥å’Œè©•ä¼°',
                        'é¢¨éšªç®¡æ§': 'é¢¨éšªç®¡ç†',
                        'å¯¦é«”é¢¨éšª': 'ç‰©ç†é¢¨éšª',
                        'è½‰å‹é¢¨éšª': 'è½‰æ›é¢¨éšª',
                        'è²¡å‹™å½±éŸ¿': 'è²¡å‹™æ•ˆæ‡‰',
                        'è²¡å‹™è¡æ“Š': 'è²¡å‹™å½±éŸ¿',
                        'è³‡æœ¬é…ç½®': 'è³‡æºé…ç½®',
                        'æŠ•è³‡æ±ºç­–': 'è³‡æœ¬é…ç½®æ±ºç­–',
                        'å…¬å¸æ²»ç†': 'æ²»ç†çµæ§‹',
                        'è‘£äº‹æœƒ': 'æ²»ç†æ©Ÿæ§‹',
                        'æ°¸çºŒå§”å“¡æœƒ': 'æ°¸çºŒæ€§å§”å“¡æœƒ',
                        'è³‡è¨Šæ­éœ²': 'ä¿¡æ¯æŠ«éœ²',
                        'é€æ˜åº¦': 'é€æ˜æ€§',
                        'å ±å‘Šæº–å‰‡': 'æŠ«éœ²æº–å‰‡'
                    };
                }

                normalizeTerminology(text) {
                    const terminologyDict = this.getTerminologyDict();
                    let normalizedText = text;
                    
                    for (const [original, standard] of Object.entries(terminologyDict)) {
                        const regex = new RegExp(original.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
                        normalizedText = normalizedText.replace(regex, standard);
                    }
                    
                    return normalizedText;
                }

                // åŸºæ–¼é—œéµè©çš„é›¢ç·šåˆ†æ
                async getKeywordBasedScores(source, candidates) {
                    const sourceTokens = tokenize(source).filter(t => !STOPWORDS.has(t) && t.length > 1);
                    const sourceSet = new Set(sourceTokens);
                    
                    return candidates.map(candidate => {
                        const candidateTokens = tokenize(candidate).filter(t => !STOPWORDS.has(t) && t.length > 1);
                        const candidateSet = new Set(candidateTokens);
                        
                        // è¨ˆç®— Jaccard ç›¸ä¼¼åº¦
                        let intersection = 0;
                        sourceSet.forEach(token => {
                            if (candidateSet.has(token)) intersection++;
                        });
                        
                        const union = sourceSet.size + candidateSet.size - intersection;
                        const jaccardScore = union === 0 ? 0 : intersection / union;
                        
                        // èª¿æ•´åˆ†æ•¸ç¯„åœä¸¦åŠ å…¥ä¸€äº›éš¨æ©Ÿæ€§ä»¥æ¨¡æ“¬èªç¾©åˆ†æ
                        const adjustedScore = Math.min(jaccardScore * 2, 1.0);
                        return Math.max(0, adjustedScore);
                    });
                }

                async encodeTexts(texts) {
                    throw new Error('Local encoding service not available - using fallback analysis');
                }

                async calculateSimilarity(sourceEmbedding, candidateEmbeddings) {
                    throw new Error('Local similarity service not available - using fallback analysis');
                }

                async getLocalSemanticScores(source, candidates, threshold = 0.3) {
                    try {
                        // æ ¹æ“šé¸æ“‡çš„æ¨¡å‹æ±ºå®šåˆ†ææ–¹æ³•
                        if (currentModelMode === 'keyword-fallback') {
                            console.log('ä½¿ç”¨é—œéµè©åŒ¹é…åˆ†æ...');
                            return this.fallbackAnalysis(source, candidates);
                        }
                        
                        console.log(`ä½¿ç”¨${currentModelMode}æ¨¡å‹é€²è¡Œèªç¾©åˆ†æ...`);
                        
                        // å‹•æ…‹é¸æ“‡ç«¯é»å’ŒAPIè·¯å¾‘
                        const endpoint = getSelectedModelEndpoint();
                        const apiPath = getSelectedModelApiPath();
                        
                        let requestBody;
                        
                        // æ ¹æ“šæ¨¡å‹é¡å‹æ§‹å»ºä¸åŒçš„è«‹æ±‚é«”
                        if (currentModelMode === 'dual-model') {
                            requestBody = {
                                source: source,
                                candidates: candidates
                            };
                        } else {
                            requestBody = {
                                source: source,
                                candidates: candidates
                            };
                        }
                        
                        // ç™¼é€è«‹æ±‚
                        const response = await fetch(`${endpoint}${apiPath}`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify(requestBody),
                        });

                        if (!response.ok) {
                            throw new Error(`Smart similarity request failed: ${response.status}`);
                        }

                        const result = await response.json();
                        let similarities;
                        
                        // æ ¹æ“šä¸åŒæ¨¡å‹è™•ç†è¿”å›çµæœ
                        if (currentModelMode === 'dual-model') {
                            similarities = result.similarities || result.scores || [];
                            
                            // é›™æ¨¡å‹è©³ç´°ä¿¡æ¯
                            console.log(`[${currentModelMode}] é›™æ¨¡å‹åˆ†æå®Œæˆ`);
                            console.log(`åˆ†æ•¸: ${similarities.length} é …`);
                            console.log(`ä½¿ç”¨æ¨¡å‹: ${result.model_used || 'dual-gemma-qwen3-fused'}`);
                            console.log(`è™•ç†æ™‚é–“: ${result.processing_time?.toFixed(3)}ç§’`);
                            
                            if (similarities.length > 0) {
                                const maxScore = Math.max(...similarities);
                                const minScore = Math.min(...similarities);
                                console.log(`åˆ†æ•¸ç¯„åœ: ${minScore.toFixed(4)} - ${maxScore.toFixed(4)}`);
                            }
                            
                        } else {
                            similarities = result.scores || [];
                            
                            // å–®æ¨¡å‹è©³ç´°ä¿¡æ¯
                            console.log(`[${currentModelMode}] å–®æ¨¡å‹åˆ†æå®Œæˆ`);
                            const nz = similarities.filter(s => Math.abs(s) > 1e-12).length;
                            const min = similarities.length ? Math.min(...similarities) : 0;
                            const max = similarities.length ? Math.max(...similarities) : 0;
                            
                            console.log(`åˆ†æ•¸: ${similarities.length} é …, éé›¶: ${nz}, ç¯„åœ: ${min.toFixed(4)} - ${max.toFixed(4)}`);
                            
                            if (result.max_primary !== undefined) {
                                console.log(`ä¸»è¦æ¨¡å‹æœ€é«˜åˆ†: ${result.max_primary.toFixed(4)}`);
                            }
                            
                            if (result.used_fallback) {
                                console.log(`å·²å•Ÿç”¨å‚™æ´æ¨¡å‹, å‚™æ´æœ€é«˜åˆ†: ${result.max_fallback?.toFixed(4)}`);
                            }
                        }
                        
                        return similarities;
                    } catch (error) {
                        console.error('Smart semantic analysis failed:', error);
                        // å‚™æ´ï¼šä½¿ç”¨åŸºç¤é—œéµè©åˆ†æ
                        console.log('æœ¬åœ°æœå‹™ä¸å¯ç”¨ï¼Œä½¿ç”¨åŸºç¤é—œéµè©åŒ¹é…...');
                        return await this.getKeywordBasedScores(source, candidates);
                    }
                }

                async getBasicLocalSemanticScores(source, candidates) {
                    console.log('ä½¿ç”¨åŸºç¤é—œéµè©åŒ¹é…åˆ†æ...');
                    return await this.getKeywordBasedScores(source, candidates);
                }

                async getMultiLevelSemanticScores(queryTitle, queryContent, candidateSentences, candidateParagraphs, customWeights = null) {
                    try {
                        console.log('ä½¿ç”¨å¤šå±¤ç´šèªç¾©åˆ†æï¼ˆå¥å­+æ®µè½+åŠ æ¬Šæ•´åˆï¼‰...');
                        
                        const defaultWeights = {
                            "title_weight": 0.3,
                            "content_weight": 0.4,
                            "sentence_weight": 0.15,
                            "paragraph_weight": 0.15
                        };
                        
                        const weights = customWeights || defaultWeights;
                        
                        // å„ªå…ˆå˜—è©¦NPUå¢å¼·æœå‹™
                        try {
                            console.log('å˜—è©¦ä½¿ç”¨NPUå¢å¼·å¤šå±¤ç´šåˆ†æ...');
                            const queryText = [queryTitle, queryContent].filter(Boolean).join(' ');
                            const allCandidates = [...candidateSentences, ...candidateParagraphs];
                            
                            const npuResponse = await fetch('http://localhost:8004/accelerated_similarity', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({
                                    source: queryText,
                                    candidates: allCandidates,
                                    model: getCurrentModelType()
                                }),
                            });

                            if (npuResponse.ok) {
                                const npuData = await npuResponse.json();
                                if (npuData.similarities && Array.isArray(npuData.similarities)) {
                                    console.log(`[NPU-MULTILEVEL] OK. scores length=${npuData.similarities.length}`);
                                    // å¾Œç«¯æœªæä¾› similarity_detailsï¼Œè¨­ç‚º null
                                    window.lastSimilarityDetails = null;
                                    
                                    // åˆ†é›¢å¥å­å’Œæ®µè½åˆ†æ•¸
                                    const sentenceScores = npuData.similarities.slice(0, candidateSentences.length);
                                    const paragraphScores = npuData.similarities.slice(candidateSentences.length);
                                    
                                    return {
                                        weighted_scores: {
                                            sentence_level: sentenceScores,
                                            paragraph_level: paragraphScores
                                        },
                                        analysis: {
                                            max_weighted_score: Math.max(...npuData.similarities),
                                            npu_enhanced: true,
                                            processing_time: npuData.processing_time
                                        }
                                    };
                                }
                            }
                        } catch (npuError) {
                            console.log('NPUå¤šå±¤ç´šåˆ†æå¤±æ•—ï¼Œä½¿ç”¨å‚™æ´API:', npuError.message);
                        }
                        
                        // å‚™æ´ï¼šä½¿ç”¨åŸæœ‰çš„å¤šå±¤ç´šAPI
                        const response = await fetch('http://localhost:8003/advanced_similarity', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                query_title: queryTitle || "",
                                query_content: queryContent,
                                candidate_sentences: candidateSentences,
                                candidate_paragraphs: candidateParagraphs,
                                weights: weights,
                                threshold: 0.3
                            }),
                        });

                        if (!response.ok) {
                            throw new Error(`Multi-level similarity request failed: ${response.status}`);
                        }

                        const result = await response.json();
                        
                        console.log(`[MULTI-SIM] å¤šå±¤ç´šåˆ†æå®Œæˆ`);
                        console.log(`[MULTI-SIM] æœ€é«˜åŠ æ¬Šåˆ†æ•¸: ${result.analysis.max_weighted_score.toFixed(4)}`);
                        console.log(`[MULTI-SIM] å¥å­åˆ†æ: æœ€é«˜${result.analysis.sentence_analysis.max_score?.toFixed(4) || 'N/A'}, æ•¸é‡${result.analysis.sentence_analysis.count || 0}`);
                        console.log(`[MULTI-SIM] æ®µè½åˆ†æ: æœ€é«˜${result.analysis.paragraph_analysis.max_score?.toFixed(4) || 'N/A'}, æ•¸é‡${result.analysis.paragraph_analysis.count || 0}`);
                        console.log(`[MULTI-SIM] æ¬Šé‡åˆ†é…:`, result.analysis.weight_distribution);
                        
                        return result;
                    } catch (error) {
                        console.error('Multi-level semantic analysis failed:', error);
                        console.log('æœ¬åœ°æœå‹™ä¸å¯ç”¨ï¼Œä½¿ç”¨é›¢ç·šé—œéµè©åˆ†æ...');
                        
                        const queryText = [queryTitle, queryContent].filter(Boolean).join(' ');
                        const sentenceScores = await this.getKeywordBasedScores(queryText, candidateSentences);
                        const paragraphScores = await this.getKeywordBasedScores(queryText, candidateParagraphs);
                        
                        return {
                            weighted_scores: {
                                sentence_level: sentenceScores,
                                paragraph_level: paragraphScores
                            },
                            analysis: {
                                max_weighted_score: Math.max(...sentenceScores, ...paragraphScores),
                                sentence_analysis: { count: sentenceScores.length, max_score: Math.max(...sentenceScores) },
                                paragraph_analysis: { count: paragraphScores.length, max_score: Math.max(...paragraphScores) },
                                weight_distribution: { title_weight: 0.3, content_weight: 0.4, sentence_weight: 0.15, paragraph_weight: 0.15 }
                            }
                        };
                    }
                }

                generateExplanation(matchResult, article) {
                    // ç”ŸæˆåŒ¹é…è§£é‡‹èªªæ˜
                    const explanations = [];
                    
                    if (matchResult.analysis) {
                        const analysis = matchResult.analysis;
                        
                        // ç¸½é«”åˆ†æ•¸èªªæ˜
                        explanations.push(` ç¸½é«”åŒ¹é…åº¦: ${(analysis.max_weighted_score * 100).toFixed(1)}%`);
                        
                        // æ¬Šé‡åˆ†é…èªªæ˜
                        const weights = analysis.weight_distribution;
                        if (weights.title_weight > 0) {
                            explanations.push(` æ¨™é¡Œæ¬Šé‡: ${(weights.title_weight * 100)}%`);
                        }
                        if (weights.content_weight > 0) {
                            explanations.push(` å…§å®¹æ¬Šé‡: ${(weights.content_weight * 100)}%`);
                        }
                        
                        // å¥å­å±¤ç´šåˆ†æ
                        if (analysis.sentence_analysis && analysis.sentence_analysis.count > 0) {
                            const sentenceMax = (analysis.sentence_analysis.max_score * 100).toFixed(1);
                            explanations.push(` å¥å­å±¤ç´š: æœ€é«˜åŒ¹é… ${sentenceMax}% (${analysis.sentence_analysis.count} å€‹å¥å­)`);
                        }
                        
                        // æ®µè½å±¤ç´šåˆ†æ
                        if (analysis.paragraph_analysis && analysis.paragraph_analysis.count > 0) {
                            const paragraphMax = (analysis.paragraph_analysis.max_score * 100).toFixed(1);
                            explanations.push(` æ®µè½å±¤ç´š: æœ€é«˜åŒ¹é… ${paragraphMax}% (${analysis.paragraph_analysis.count} å€‹æ®µè½)`);
                        }
                        
                        // åŒ¹é…è³ªé‡è©•ä¼°
                        if (analysis.max_weighted_score > 0.7) {
                            explanations.push(` é«˜åº¦åŒ¹é… - å…§å®¹é«˜åº¦ç›¸é—œ`);
                        } else if (analysis.max_weighted_score > 0.4) {
                            explanations.push(` ä¸­åº¦åŒ¹é… - æœ‰ç›¸é—œæ€§ä½†å¯åŠ å¼·`);
                        } else if (analysis.max_weighted_score > 0.2) {
                            explanations.push(`âšª ä½åº¦åŒ¹é… - ç›¸é—œæ€§è¼ƒä½`);
                        } else {
                            explanations.push(` å¹¾ä¹ç„¡åŒ¹é… - å»ºè­°æª¢è¦–å…§å®¹ç›¸é—œæ€§`);
                        }
                    }
                    
                    return explanations.join('\n');
                }
            }

            // åˆå§‹åŒ–æœ¬åœ°åˆ†æå™¨
            const localAnalyzer = new LocalSemanticAnalyzer();

            // === å‰ç«¯å„ªåŒ–åŠŸèƒ½é›†æˆ ===

            // ç³»çµ±é…ç½®å°è±¡
            const systemConfig = {
                selectedModel: 'multi-level',
                tokenLimit: 4096,
                threshold: 0.3,
                weights: {
                    title_weight: 0.2,    // é™ä½æ¨™é¡Œæ¬Šé‡ï¼šé¿å…éåº¦ä¾è³´æ¨™é¡Œ
                    content_weight: 0.5,  // æé«˜å…§å®¹æ¬Šé‡ï¼šé‡è¦–æ¢æ–‡å…§å®¹åŒ¹é…
                    sentence_weight: 0.2, // æé«˜å¥å­æ¬Šé‡ï¼šé‡è¦–ç´°ç¯€èªç¾©
                    paragraph_weight: 0.1 // é™ä½æ®µè½æ¬Šé‡ï¼šé¿å…ä¸Šä¸‹æ–‡å¹²æ“¾
                },
                gpuStatus: 'unknown',
                // æ–°å¢çš„é…ç½®é …
                pdfQuality: 'standard',           // PDFè™•ç†å“è³ª
                languagePreference: 'auto',       // èªè¨€åå¥½
                pageLimit: 50,                    // é æ•¸è™•ç†ä¸Šé™
                memoryOptimization: false,        // è¨˜æ†¶é«”å„ªåŒ–
                parallelProcessing: 'medium',     // ä¸¦è¡Œè™•ç†
                pdfRenderScale: 1.5,             // PDFæ¸²æŸ“ç¸®æ”¾æ¯”ä¾‹
                exportFormats: {                  // å°å‡ºæ ¼å¼è¨­ç½®
                    html: true,
                    json: false,
                    excel: false,
                    pdf: false
                },
                primaryModel: 'unknown'
            };

            // System initialization will be handled in the main execution block

            async function initializeSystemStatus() {
                // ç³»çµ±ç‹€æ…‹é¢æ¿å·²ç§»é™¤
                // const statusPanel = document.getElementById('systemStatus');
                // if (statusPanel) {
                //     statusPanel.style.display = 'block';
                // }
                
                // åˆå§‹åŒ–æ¨¡å‹é¸æ“‡ç‹€æ…‹
                console.log(' åˆå§‹åŒ–æ¨¡å‹é¸æ“‡ç³»çµ±...');
                console.log(` ç•¶å‰é¸æ“‡æ¨¡å‹: ${currentModelMode}`);

                // æª¢æŸ¥æœ¬åœ°æœå‹™ç‹€æ…‹
                await checkLocalServiceStatus();
                
                console.log(' å‰ç«¯å„ªåŒ–åŠŸèƒ½å·²å•Ÿç”¨');
            }

            async function checkLocalServiceStatus() {
                try {
                    // æª¢æŸ¥åŠ é€Ÿç‰ˆé›™æ¨¡å‹èåˆæœå‹™å¥åº·ç‹€æ…‹
                    const response = await fetchWithTimeout('http://localhost:8004/health', { cache: 'no-store' }, 6000);
                    if (response.ok) {
                        const healthData = await response.json();
                        updateSystemStatus(healthData);
                    } else {
                        throw new Error('Service unavailable');
                    }
                } catch (error) {
                    console.log('æœ¬åœ°æœå‹™ä¸å¯ç”¨ï¼Œå°‡ä½¿ç”¨å‚™æ´æ¨¡å¼');
                    updateSystemStatus(null);
                }
            }

            function updateSystemStatus(healthData) {
                console.log("[DEBUG] Health Check Data:", healthData);
                // ç³»çµ±ç‹€æ…‹é¢æ¿å…ƒç´ å·²ç§»é™¤ï¼Œæ·»åŠ nullæª¢æŸ¥
                const gpuStatusElement = document.getElementById('gpuStatus');
                const primaryModelElement = document.getElementById('primaryModel');
                const tokenSupportElement = document.getElementById('tokenSupport');
                const semanticStatusElement = document.getElementById('status-semantic');

                if (healthData && healthData.status === 'healthy') {
                    // æ›´æ–°GPU/NPUåŠ é€Ÿç‹€æ…‹ - æª¢æ¸¬MPSæ”¯æ´ï¼ˆç³»çµ±ç‹€æ…‹é¢æ¿å·²ç§»é™¤ï¼Œè·³éæ›´æ–°ï¼‰
                    if (gpuStatusElement) {
                        if (healthData.device === 'mps' || healthData.mps_available) {
                            gpuStatusElement.innerHTML = ' MPSåŠ é€Ÿ (Metal Performance Shaders)';
                            gpuStatusElement.style.color = '#388e3c';
                        } else if (healthData.device === 'cuda') {
                            gpuStatusElement.innerHTML = ' CUDAåŠ é€Ÿ';
                            gpuStatusElement.style.color = '#388e3c';
                        } else {
                            gpuStatusElement.innerHTML = ' CPUé‹ç®— (é«˜æ€§èƒ½å„ªåŒ–)';
                            gpuStatusElement.style.color = '#f57c00';
                        }
                    }
                    
                    // Check if FAISS acceleration is availableï¼ˆç³»çµ±ç‹€æ…‹é¢æ¿å·²ç§»é™¤ï¼Œè·³éæ›´æ–°ï¼‰
                    if (primaryModelElement) {
                        if (healthData.models && healthData.models.faiss_retrieval) {
                            primaryModelElement.textContent = ' FAISSå‘é‡åŠ é€Ÿ + Sentence Transformers';
                            primaryModelElement.style.color = '#1a73e8';
                        } else if (healthData.models && healthData.models.dual_fusion) {
                            primaryModelElement.textContent = ' é›™æ¨¡å‹èåˆ (Gemma+Qwen3)';
                            primaryModelElement.style.color = '#1a73e8';
                        } else {
                            primaryModelElement.textContent = 'æœå‹™è¼‰å…¥ä¸­...';
                            primaryModelElement.style.color = '#ff9800';
                        }
                    }

                    // Check device type and display FAISS acceleration statusï¼ˆç³»çµ±ç‹€æ…‹é¢æ¿å·²ç§»é™¤ï¼Œè·³éæ›´æ–°ï¼‰
                    if (gpuStatusElement) {
                        if (healthData.models && healthData.models.faiss_retrieval) {
                            gpuStatusElement.innerHTML = ' FAISSå‘é‡åŠ é€Ÿ (15-25x)';
                            gpuStatusElement.style.color = '#2e7d32';
                        } else if (healthData.device === 'mps' && healthData.mps_available) {
                            gpuStatusElement.innerHTML = ' GPUåŠ é€Ÿ (MPS)';
                            gpuStatusElement.style.color = 'green';
                        } else if (healthData.device === 'cpu') {
                            gpuStatusElement.innerHTML = ' é›™æ¨¡å‹èåˆ (CPU)';
                            gpuStatusElement.style.color = '#1a73e8';
                        } else {
                            gpuStatusElement.innerHTML = ' é›™æ¨¡å‹èåˆ';
                            gpuStatusElement.style.color = 'green';
                        }
                    }

                    // FAISS accelerated service settingsï¼ˆç³»çµ±ç‹€æ…‹é¢æ¿å·²ç§»é™¤ï¼Œè·³éæ›´æ–°ï¼‰
                    if (tokenSupportElement) {
                        if (healthData.models && healthData.models.faiss_retrieval) {
                            tokenSupportElement.textContent = '2048 tokens (FAISSæ··åˆæª¢ç´¢)';
                        } else {
                            tokenSupportElement.textContent = '2048 tokens (é›™æ¨¡å‹èåˆ)';
                        }
                    }

                    // Update Semantic Service line with FAISS acceleration info
                    if (semanticStatusElement) {
                        const device = healthData.device || 'cpu';
                        let modelName = 'semantic-service';
                        if (healthData.models && healthData.models.faiss_retrieval) {
                            modelName = 'faiss-hybrid-accelerated';
                        } else if (healthData.models && healthData.models.dual_fusion) {
                            modelName = 'dual-gemma-qwen3-fused';
                        }
                        semanticStatusElement.textContent = `Online (${modelName}, ${device})`;
                    }
                } else {
                    // Fallback for when service is offline or wrong formatï¼ˆç³»çµ±ç‹€æ…‹é¢æ¿å·²ç§»é™¤ï¼Œè·³éæ›´æ–°ï¼‰
                    if (gpuStatusElement) {
                        gpuStatusElement.innerHTML = ' æœå‹™é›¢ç·š';
                        gpuStatusElement.style.color = 'red';
                    }
                    if (primaryModelElement) {
                        primaryModelElement.textContent = 'é ç¨‹APIæ¨¡å¼ (å‚™æ´)';
                        primaryModelElement.style.color = '#d93025';
                    }
                    if (tokenSupportElement) {
                        tokenSupportElement.textContent = '4096 tokens (å¢å¼·)';
                    }

                    // Ensure Semantic Service line reflects offline fallback
                    if (semanticStatusElement) {
                        semanticStatusElement.textContent = 'Offline (ä½¿ç”¨é—œéµè©åŒ¹é…)';
                    }
                }
                // ç³»çµ±ç‹€æ…‹é¢æ¿å·²ç§»é™¤
                // document.getElementById('systemStatus').style.display = 'block';
            }

            function setupEventListeners() {
                // æ¨¡å‹é¸æ“‡è®Šæ›´
                const modelSelect = document.getElementById('modelSelection');
                if (modelSelect) {
                    modelSelect.addEventListener('change', function() {
                        systemConfig.selectedModel = this.value;
                        console.log(`åˆ‡æ›åˆ†ææ¨¡å‹: ${this.value}`);
                        updateProcessingMode();
                    });
                }

                // Tokené™åˆ¶è®Šæ›´
                const tokenSelect = document.getElementById('tokenLimit');
                if (tokenSelect) {
                    tokenSelect.value = systemConfig.tokenLimit;
                    tokenSelect.addEventListener('change', function() {
                        systemConfig.tokenLimit = parseInt(this.value);
                        console.log(`Tokené™åˆ¶è¨­ç‚º: ${this.value}`);
                    });
                }

                // é–¾å€¼è®Šæ›´
                const thresholdSlider = document.getElementById('similarityThreshold');
                if (thresholdSlider) {
                    thresholdSlider.addEventListener('input', function() {
                        systemConfig.threshold = parseFloat(this.value);
                    });
                }

                // æ¨¡å‹é¸æ“‡é¢æ¿äº‹ä»¶ç›£è½å™¨
                setupModelSelectionListeners();
            }

            function updateProcessingMode() {
                const processingModeElement = document.getElementById('processingMode');
                const modeMap = {
                    'multi-level': ' å¤šå±¤ç´šåˆ†æ',
                    'smart-fallback': ' æ™ºæ…§å‚™æ´',
                    'basic-local': ' åŸºç¤æœ¬åœ°',
                    'remote-api': ' é ç¨‹API'
                };
                
                if (processingModeElement) {
                    processingModeElement.innerHTML = `<span style="color: #4caf50;">${modeMap[systemConfig.selectedModel] || 'æœªçŸ¥'}</span>`;
                }
            }

            function setupModelSelectionListeners() {
                const modelOptions = document.querySelectorAll('.model-option input[type="radio"]');
                
                modelOptions.forEach(radio => {
                    radio.addEventListener('change', function() {
                        if (this.checked) {
                            // æ›´æ–°é¸ä¸­ç‹€æ…‹çš„è¦–è¦ºæ•ˆæœ
                            document.querySelectorAll('.model-option').forEach(option => {
                                option.classList.remove('selected');
                            });
                            
                            this.closest('.model-option').classList.add('selected');
                            
                            // æ›´æ–°å…¨å±€æ¨¡å‹é…ç½®
                            const selectedModel = this.value;
                            updateSelectedModel(selectedModel);
                            
                            console.log(` æ¨¡å‹åˆ‡æ›è‡³: ${selectedModel}`);
                        }
                    });
                });
            }

            function updateSelectedModel(modelType) {
                // æ›´æ–°å…¨å±€é…ç½®
                currentModelMode = modelType === 'dual' ? 'dual-model' : `single-${modelType}`;
                
                // æ›´æ–°æ¨¡å‹ç«¯é»é…ç½®
                switch(modelType) {
                    case 'gemma':
                        modelEndpoints['single-gemma'] = 'http://localhost:8004';
                        break;
                    case 'qwen':
                        modelEndpoints['single-qwen'] = 'http://localhost:8004';
                        break;
                    case 'dual':
                        modelEndpoints['dual-model'] = 'http://localhost:8004';
                        break;
                }
                
                // æ›´æ–°ç‹€æ…‹é¡¯ç¤º
                updateModelStatus(modelType);
                
                // å¦‚æœæœ‰åˆ†æçµæœï¼Œå¯ä»¥é¸æ“‡æ€§é‡æ–°åˆ†æ
                // é€™è£¡æš«æ™‚ä¸è‡ªå‹•é‡æ–°åˆ†æï¼Œè®“ç”¨æˆ¶æ‰‹å‹•è§¸ç™¼
            }

            function updateModelStatus(modelType) {
                const statusElement = document.getElementById('modelStatus');
                const statusMap = {
                    'gemma': {
                        indicator: '',
                        text: 'ç•¶å‰æ¨¡å¼ï¼šEmbeddingGemma æ¨¡å‹',
                        color: 'rgba(66, 133, 244, 0.1)',
                        borderColor: 'rgba(66, 133, 244, 0.3)'
                    },
                    'qwen': {
                        indicator: '', 
                        text: 'ç•¶å‰æ¨¡å¼ï¼šQwen3-Embedding æ¨¡å‹',
                        color: 'rgba(255, 152, 0, 0.1)',
                        borderColor: 'rgba(255, 152, 0, 0.3)'
                    },
                    'dual': {
                        indicator: '',
                        text: 'ç•¶å‰æ¨¡å¼ï¼šé›™æ¨¡å‹èåˆ (Gemma + Qwen3)',
                        color: 'rgba(52, 168, 83, 0.1)',
                        borderColor: 'rgba(52, 168, 83, 0.3)'
                    }
                };
                
                const config = statusMap[modelType];
                if (statusElement && config) {
                    statusElement.style.background = config.color;
                    statusElement.style.borderColor = config.borderColor;
                    
                    const indicatorElement = statusElement.querySelector('.status-indicator');
                    const textElement = statusElement.querySelector('.status-text');
                    
                    if (indicatorElement) indicatorElement.textContent = config.indicator;
                    if (textElement) textElement.textContent = config.text;
                }
            }

            function getCurrentModelType() {
                const checkedRadio = document.querySelector('.model-option input[type="radio"]:checked');
                return checkedRadio ? checkedRadio.value : 'dual';
            }





            // æ¨¡å‹é…ç½® - æ›´æ–°ç‚ºåŠ é€Ÿç‰ˆæœå‹™
            let currentModelMode = 'dual-model';
            let modelEndpoints = {
                'dual-model': 'http://localhost:8004',  // åŠ é€Ÿç‰ˆæœå‹™
                'single-gemma': 'http://localhost:8004',
                'single-qwen': 'http://localhost:8004',
                'keyword-fallback': 'local'
            };


            function getSelectedModelEndpoint() {
                                return modelEndpoints[currentModelMode] || 'http://localhost:8002';
            }

            function getSelectedModelApiPath() {
                switch(currentModelMode) {
                    case 'dual-model':
                        return '/accelerated_similarity';  // ä½¿ç”¨åŠ é€Ÿç‰ˆç«¯é»
                    case 'single-gemma':
                    case 'single-qwen':
                        return '/accelerated_similarity';  // ä½¿ç”¨åŠ é€Ÿç‰ˆç«¯é»
                    default:
                        return '/accelerated_similarity';  // é»˜èªä½¿ç”¨åŠ é€Ÿç‰ˆ
                }
            }


            // å¢å¼·ç‰ˆèªç¾©åˆ†æå‡½æ•¸ï¼Œæ”¯æ´æœ¬åœ°å’Œé ç¨‹API
            //  æ–°å¢ï¼šæ‰¹é‡èªç¾©åˆ†æå‡½æ•¸
            async function getBatchSemanticScores(source, candidatesBatch) {
                try {
                    console.log(` æ‰¹é‡èªç¾©åˆ†æ: ${candidatesBatch.length}å€‹æ–‡æœ¬çµ„`);
                    
                    const response = await fetch('http://localhost:8004/batch_similarity', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            source: source,
                            candidates_batch: candidatesBatch,
                            model: getCurrentModelType()
                        })
                    });

                    if (response.ok) {
                        const data = await response.json();
                        console.log(` æ‰¹é‡è™•ç†çµæœ: ${data.batch_size}å€‹æ‰¹æ¬¡, æ€§èƒ½æå‡: ${data.performance_gain}`);
                        return data.batch_results;
                    } else {
                        throw new Error(`Batch similarity request failed: ${response.status}`);
                    }
                } catch (error) {
                    console.error('æ‰¹é‡èªç¾©åˆ†æå¤±æ•—ï¼Œé™ç´šç‚ºå–®æ¬¡è™•ç†:', error);
                    // é™ç´šç‚ºé€ä¸€è™•ç†
                    const results = [];
                    for (const candidates of candidatesBatch) {
                        const result = await getSemanticScores(source, candidates);
                        results.push({
                            similarities: result,
                            candidates_count: candidates.length
                        });
                    }
                    return results;
                }
            }

            async function getSemanticScores(source, candidates) {
                // é¦–å…ˆå˜—è©¦æœ¬åœ°åˆ†æ
                try {
                    console.log('å˜—è©¦ä½¿ç”¨æœ¬åœ°èªç¾©åˆ†æ...');
                    return await localAnalyzer.getLocalSemanticScores(source, candidates);
                } catch (localError) {
                    console.log('æœ¬åœ°åˆ†æå¤±æ•—ï¼Œåˆ‡æ›åˆ°é ç¨‹API:', localError.message);
                }

                // å„ªå…ˆï¼šå˜—è©¦ä½¿ç”¨NPUå¢å¼·æœå‹™
                try {
                    console.log('å˜—è©¦ä½¿ç”¨NPUå¢å¼·èªç¾©åˆ†ææœå‹™...');
                    const response = await fetch('http://localhost:8002/similarity', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            source: source,
                            candidates: candidates,
                            model: 'dual'
                        }),
                    });

                    if (response.ok) {
                        const data = await response.json();
                        if (data.similarities && Array.isArray(data.similarities)) {
                            console.log(`[NPU-API] OK. scores length=${data.similarities.length}`);
                            window.lastSimilarityDetails = null;
                            return data.similarities;
                        }
                    }
                } catch (npuError) {
                    console.log('NPUæœå‹™é€£æ¥å¤±æ•—ï¼Œå˜—è©¦å‚™æ´API:', npuError.message);
                }

                // å‚™æ´ï¼šä½¿ç”¨åŸæœ‰çš„é ç¨‹API
                try {
                    const response = await fetch('http://localhost:8003/calculate_similarity/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            source: source,
                            candidates: candidates,
                            threshold: 0.3
                        }),
                    });

                    if (!response.ok) {
                        console.error('Semantic similarity API request failed:', response.status, response.statusText);
                        return new Array(candidates.length).fill(0); // Fallback
                    }

                    const data = await response.json();
                    const scores = Array.isArray(data.scores) ? data.scores : new Array(candidates.length).fill(0);
                    const nz = scores.filter(s => Math.abs(s) > 1e-12).length;
                    const min = scores.length ? Math.min(...scores) : 0;
                    const max = scores.length ? Math.max(...scores) : 0;
                    console.log(`[REMOTE-API] OK. scores length=${scores.length} nz=${nz} min=${min.toFixed(4)} max=${max.toFixed(4)}`);
                    return scores;
                } catch (error) {
                    console.error('Error calling semantic similarity API:', error);
                    console.log('ä½¿ç”¨é›¢ç·šé—œéµè©åŒ¹é…ä½œç‚ºæœ€å¾Œå‚™æ´...');
                    return await localAnalyzer.getKeywordBasedScores(source, candidates);
                }
            }

            // æ¢æ–‡ç‰¹å®šåˆ†æå‡½æ•¸ - è§£æ±ºè­‰æ“šé‡è¤‡å•é¡Œ
            async function getArticleSpecificAnalysis(article, allSentencesText, allParagraphsText) {
                try {
                    console.log(` é–‹å§‹æ¢æ–‡ç‰¹å®šåˆ†æ: ${article.id}`);
                    
                    // å„ªå…ˆä½¿ç”¨æ¢æ–‡ç‰¹å®šåˆ†æç«¯é»
                    const response = await fetch('http://localhost:8004/analyze_specific_article', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            article: article,
                            document_sentences: allSentencesText.slice(0, 500),
                            document_paragraphs: allParagraphsText.slice(0, 200)
                        }),
                    });

                    if (response.ok) {
                        const result = await response.json();
                        console.log(` æ¢æ–‡ç‰¹å®šåˆ†ææˆåŠŸ: ${article.id}, è­‰æ“šæ•¸: ${result.result?.evidences?.length || 0}`);
                        
                        // è½‰æ›ç‚ºå‰ç«¯æœŸæœ›æ ¼å¼
                        const evidences = result.result?.evidences || [];
                        const sentenceScores = new Array(allSentencesText.length).fill(0);
                        const paragraphScores = new Array(allParagraphsText.length).fill(0);
                        
                        // å°‡æ¢æ–‡ç‰¹å®šçš„è­‰æ“šæ˜ å°„å›åˆ†æ•¸é™£åˆ—
                        evidences.forEach(evidence => {
                            if (evidence.type === 'sentence' && evidence.index < sentenceScores.length) {
                                sentenceScores[evidence.index] = evidence.similarity;
                            } else if (evidence.type === 'paragraph' && evidence.index < paragraphScores.length) {
                                paragraphScores[evidence.index] = evidence.similarity;
                            }
                        });
                        
                        return {
                            sentenceScores,
                            paragraphScores,
                            analysis: {
                                max_weighted_score: result.result?.max_similarity || 0,
                                article_specific: true,
                                evidence_count: evidences.length
                            },
                            explanation: `æ¢æ–‡ç‰¹å®šåˆ†æå®Œæˆï¼Œæ‰¾åˆ° ${evidences.length} å€‹ç›¸é—œè­‰æ“š`
                        };
                    } else {
                        console.log(`æ¢æ–‡ç‰¹å®šåˆ†æå¤±æ•—ï¼Œå›é€€åˆ°å‚³çµ±åˆ†æ: ${article.id}`);
                        return await getMultiLevelSemanticAnalysis(article, allSentencesText, allParagraphsText);
                    }
                } catch (error) {
                    console.error(`æ¢æ–‡ç‰¹å®šåˆ†æéŒ¯èª¤: ${article.id}`, error);
                    return await getMultiLevelSemanticAnalysis(article, allSentencesText, allParagraphsText);
                }
            }

            // å¤šå±¤ç´šèªç¾©åˆ†æå‡½æ•¸ï¼ˆæ•´åˆå‰ç«¯é…ç½®ï¼‰
            async function getMultiLevelSemanticAnalysis(article, allSentencesText, allParagraphsText) {
                // æ ¹æ“šç”¨æˆ¶é¸æ“‡çš„åˆ†ææ¨¡å¼åŸ·è¡Œä¸åŒç­–ç•¥
                switch (systemConfig.selectedModel) {
                    case 'multi-level':
                        return await performMultiLevelAnalysis(article, allSentencesText, allParagraphsText);
                    case 'smart-fallback':
                        return await performSmartFallbackAnalysis(article, allSentencesText, allParagraphsText);
                    case 'basic-local':
                        return await performBasicLocalAnalysis(article, allSentencesText, allParagraphsText);
                    case 'remote-api':
                        return await performRemoteAPIAnalysis(article, allSentencesText, allParagraphsText);
                    default:
                        return await performMultiLevelAnalysis(article, allSentencesText, allParagraphsText);
                }
            }

            async function performMultiLevelAnalysis(article, allSentencesText, allParagraphsText) {
                try {
                    console.log(' åŸ·è¡Œå¤šå±¤ç´šèªç¾©åˆ†æ...');
                    
                    const multiLevelResult = await localAnalyzer.getMultiLevelSemanticScores(
                        article.title || "",
                        article.content || "",
                        allSentencesText,
                        allParagraphsText,
                        systemConfig.weights  // ä½¿ç”¨ç”¨æˆ¶é…ç½®çš„æ¬Šé‡
                    );
                    
                    return {
                        sentenceScores: multiLevelResult.weighted_scores?.sentence_level || [],
                        paragraphScores: multiLevelResult.weighted_scores?.paragraph_level || [],
                        analysis: multiLevelResult.analysis,
                        explanation: localAnalyzer.generateExplanation(multiLevelResult, article)
                    };
                    
                } catch (error) {
                    console.log('å¤šå±¤ç´šåˆ†æå¤±æ•—ï¼Œè‡ªå‹•åˆ‡æ›åˆ°æ™ºæ…§å‚™æ´æ¨¡å¼:', error.message);
                    return await performSmartFallbackAnalysis(article, allSentencesText, allParagraphsText);
                }
            }

            async function performSmartFallbackAnalysis(article, allSentencesText, allParagraphsText) {
                try {
                    console.log(' åŸ·è¡Œæ™ºæ…§å‚™æ´åˆ†æ...');
                    const articleContent = [article.title, article.content].filter(Boolean).join(' ');
                    
                    // ä½¿ç”¨ç”¨æˆ¶é…ç½®çš„é–¾å€¼
                    const sentenceScores = await localAnalyzer.getLocalSemanticScores(articleContent, allSentencesText, systemConfig.threshold);
                    const paragraphScores = await localAnalyzer.getLocalSemanticScores(articleContent, allParagraphsText, systemConfig.threshold);
                    
                    return {
                        sentenceScores,
                        paragraphScores,
                        analysis: { max_weighted_score: Math.max(...sentenceScores, ...paragraphScores) },
                        explanation: `æ™ºæ…§å‚™æ´åˆ†æå®Œæˆ (é–¾å€¼: ${systemConfig.threshold})`
                    };
                } catch (error) {
                    console.log('æ™ºæ…§å‚™æ´åˆ†æå¤±æ•—ï¼Œåˆ‡æ›åˆ°åŸºç¤æœ¬åœ°åˆ†æ:', error.message);
                    return await performBasicLocalAnalysis(article, allSentencesText, allParagraphsText);
                }
            }

            async function performBasicLocalAnalysis(article, allSentencesText, allParagraphsText) {
                try {
                    console.log(' åŸ·è¡ŒåŸºç¤æœ¬åœ°åˆ†æ...');
                    const articleContent = [article.title, article.content].filter(Boolean).join(' ');
                    const sentenceScores = await getSemanticScores(articleContent, allSentencesText);
                    const paragraphScores = await getSemanticScores(articleContent, allParagraphsText);
                    
                    return {
                        sentenceScores,
                        paragraphScores,
                        analysis: null,
                        explanation: "åŸºç¤æœ¬åœ°èªç¾©åˆ†æ"
                    };
                } catch (error) {
                    console.log('åŸºç¤æœ¬åœ°åˆ†æå¤±æ•—ï¼Œæœ€å¾Œåˆ‡æ›åˆ°é ç¨‹API:', error.message);
                    return await performRemoteAPIAnalysis(article, allSentencesText, allParagraphsText);
                }
            }

            async function performRemoteAPIAnalysis(article, allSentencesText, allParagraphsText) {
                console.log(' åŸ·è¡Œé ç¨‹APIåˆ†æ...');
                const articleContent = [article.title, article.content].filter(Boolean).join(' ');
                
                // ç›´æ¥ä½¿ç”¨é ç¨‹APIï¼Œè·³éæœ¬åœ°æœå‹™
                try {
                    const sentenceScores = await getRemoteSemanticScores(articleContent, allSentencesText);
                    const paragraphScores = await getRemoteSemanticScores(articleContent, allParagraphsText);
                    
                    return {
                        sentenceScores,
                        paragraphScores,
                        analysis: null,
                        explanation: "é ç¨‹APIèªç¾©åˆ†æ"
                    };
                } catch (error) {
                    console.log('é ç¨‹APIåˆ†æå¤±æ•—ï¼Œä½¿ç”¨é—œéµè©åŒ¹é…å‚™æ´:', error.message);
                    return {
                        sentenceScores: new Array(allSentencesText.length).fill(0),
                        paragraphScores: new Array(allParagraphsText.length).fill(0),
                        analysis: null,
                        explanation: "æ‰€æœ‰èªç¾©åˆ†ææ–¹æ³•å¤±æ•—ï¼Œåƒ…ä½¿ç”¨é—œéµè©åŒ¹é…"
                    };
                }
            }

            async function getRemoteSemanticScores(source, candidates) {
                try {
                    const response = await fetch('http://localhost:8003/calculate_similarity/', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            source: source, 
                            candidates: candidates, 
                            threshold: systemConfig.threshold 
                        })
                    });
                    
                    if (!response.ok) throw new Error(`Remote API failed: ${response.status}`);
                    
                    const data = await response.json();
                    return data.scores || new Array(candidates.length).fill(0);
                } catch (error) {
                    console.log('é ç¨‹APIä¸å¯ç”¨ï¼Œä½¿ç”¨é—œéµè©åŒ¹é…...');
                    return await localAnalyzer.getKeywordBasedScores(source, candidates);
                }
            }

            async function performAIAnalysis(text, fileName, totalPages, isEnglish) {
                statusElement.textContent = 'é–‹å§‹èˆ‡IFRS S1æ¢æ–‡é€²è¡Œæ¯”å°ï¼ˆæ‰¹é‡ä¸¦è¡Œåˆ†æï¼‰...';
                const results = [];
                const allArticles = isEnglish ? ifrs1EnData.articles : ifrs1Data.articles;
                const articles = allArticles;

                const globalSentences = sentencesByPage.flatMap(p => p.sentences.map(s => ({ page: p.page, sentence: s })));
                const globalParagraphs = paragraphsByPage.flatMap(p => p.paragraphs.map(paragraph => ({ page: p.page, paragraph: paragraph })));

                const allSentencesText = globalSentences.map(s => s.sentence);
                const allParagraphsText = globalParagraphs.map(p => p.paragraph);

                //  æ¢æ–‡é€ä¸€ç‰¹å®šåˆ†ææ¶æ§‹ - ä¿®å¾©è­‰æ“šé‡è¤‡å•é¡Œ
                const BATCH_SIZE = 6; // æ¯æ‰¹è™•ç†6å€‹æ¢æ–‡
                const batches = [];
                
                for (let i = 0; i < articles.length; i += BATCH_SIZE) {
                    batches.push(articles.slice(i, i + BATCH_SIZE));
                }

                console.log(` æ¢æ–‡é€ä¸€ç‰¹å®šåˆ†æ: ${articles.length}æ¢æ–‡ åˆ†ç‚º ${batches.length}æ‰¹æ¬¡, æ¯æ‰¹${BATCH_SIZE}æ¢æ–‡`);
                
                for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
                    const batch = batches[batchIndex];
                    const progress = Math.round(((batchIndex + 1) / batches.length) * 100);
                    statusElement.textContent = `æ¢æ–‡ç‰¹å®šåˆ†æé€²åº¦ ${progress}% (${batchIndex + 1}/${batches.length} æ‰¹æ¬¡)...`;
                    
                    // ä¸¦è¡Œè™•ç†ç•¶å‰æ‰¹æ¬¡çš„æ‰€æœ‰æ¢æ–‡
                    const batchPromises = batch.map(async (article, indexInBatch) => {
                        const globalIndex = batchIndex * BATCH_SIZE + indexInBatch;
                        console.log(` æ¢æ–‡ç‰¹å®šåˆ†æ ${globalIndex + 1}/${articles.length}: ${article.id}`);
                        
                        const coreTokens = extractCoreConceptTokens(article);
                        const keywordSet = new Set((Array.isArray(article.keywords) ? article.keywords : []).map(k => normalizeText(k)));

                        // ä½¿ç”¨æ¢æ–‡ç‰¹å®šåˆ†æç«¯é» - è§£æ±ºè­‰æ“šé‡è¤‡å•é¡Œ
                        const analysisResult = await getArticleSpecificAnalysis(article, allSentencesText, allParagraphsText);
                        const { sentenceScores, paragraphScores, analysis, explanation } = analysisResult;

                        const sentenceCandidates = globalSentences.map((gs, index) => {
                        const { coreHit, kwHit, matchedCore } = scoreSentence(gs.sentence, coreTokens, keywordSet);
                        const similarity_detail = window.lastSimilarityDetails && window.lastSimilarityDetails[index] 
                            ? window.lastSimilarityDetails[index] 
                            : null;
                        
                        // å¦‚æœæœ‰ç›¸é—œåº¦è©³ç´°ä¿¡æ¯ï¼Œä½¿ç”¨å…¶ä¸­çš„ç›¸ä¼¼åº¦å€¼
                        const simValue = similarity_detail ? similarity_detail.similarity : sentenceScores[index];
                        
                        if (similarity_detail && index < 3) {
                            console.log(`å¥å­ ${index} ç›¸é—œåº¦è©³ç´°ä¿¡æ¯:`, similarity_detail.label, similarity_detail.percentage + '%', 'é¡è‰²é…ç½®:', similarity_detail.colors);
                        }
                        
                        return { ...gs, coreHit, kwHit, sim: simValue, matchedCore, similarity_detail };
                    }).filter(c => c.sim > 0.02); // çœŸå¯¦èªç¾©æ¨¡å‹ï¼šé€²ä¸€æ­¥é™ä½é–€æª»ä»¥æ•æ‰æ›´ç´°å¾®çš„èªç¾©é—œè¯

                    const paraCandidates = globalParagraphs.map((gp, index) => {
                        const { coreHit, kwHit, matchedCore } = scoreSentence(gp.paragraph, coreTokens, keywordSet);
                        const paragraphDetailIndex = globalSentences.length + index;
                        const similarity_detail = window.lastSimilarityDetails && window.lastSimilarityDetails[paragraphDetailIndex] 
                            ? window.lastSimilarityDetails[paragraphDetailIndex] 
                            : null;
                        
                        // å¦‚æœæœ‰ç›¸é—œåº¦è©³ç´°ä¿¡æ¯ï¼Œä½¿ç”¨å…¶ä¸­çš„ç›¸ä¼¼åº¦å€¼
                        const simValue = similarity_detail ? similarity_detail.similarity : paragraphScores[index];
                        
                        return { ...gp, coreHit, kwHit, sim: simValue, matchedCore, similarity_detail };
                    }).filter(c => c.sim > 0.02); // çœŸå¯¦èªç¾©æ¨¡å‹ï¼šé€²ä¸€æ­¥é™ä½é–€æª»ä»¥æ•æ‰æ›´ç´°å¾®çš„èªç¾©é—œè¯

                    // ç´”èªç¾©æ’åºï¼šå®Œå…¨åŸºæ–¼NPUè¨ˆç®—çš„å‘é‡è·é›¢ç›¸ä¼¼åº¦
                    console.log('ä½¿ç”¨ç´”èªç¾©ç›¸ä¼¼åº¦æ’åºï¼Œä¸ä¾è³´é—œéµå­—åŒ¹é…');
                    sentenceCandidates.sort((a, b) => b.sim - a.sim);
                    paraCandidates.sort((a, b) => b.sim - a.sim);
                    const topSentences = sentenceCandidates.slice(0, 4);
                    const topParagraphs = paraCandidates.slice(0, 2);
                    const combined = [...topSentences, ...topParagraphs];

                    const evidences = [];
                    for (const c of combined) {
                        try {
                            const unmatchedCore = coreTokens.filter(t => !c.matchedCore.includes(t)).slice(0, 6);
                            const contentText = c.sentence || c.paragraph || '';
                            
                            // å„ªå…ˆä½¿ç”¨AIç”Ÿæˆçš„è­‰æ“šè§£é‡‹
                            let reasoning = await generateAIReasoning(article, contentText, c.page, c.matchedCore || [], unmatchedCore, c.sim || 0);
                            
                            // å‚™æ´ï¼šå˜—è©¦Transformer API
                            if (!reasoning) {
                                reasoning = await generateTransformerReasoning(article, contentText, c.page, c.matchedCore || [], unmatchedCore);
                            }
                            
                            // æœ€å¾Œå‚™æ´ï¼šä½¿ç”¨å‹•æ…‹æœ¬åœ°ç”Ÿæˆ
                            if (!reasoning) {
                                reasoning = generateDynamicReasoning(article, contentText, c.page, c.matchedCore || [], unmatchedCore, c.sim || 0);
                            }
                            evidences.push({
                                type: c.paragraph ? 'paragraph' : 'sentence',
                                page: c.page,
                                content: contentText,
                                reasoning,
                                coreHit: c.coreHit || 0,
                                kwHit: c.kwHit || 0,
                                sim: c.sim || 0,
                                analysis_level: c.paragraph ? 'æ®µè½ç´š' : 'å¥å­ç´š',
                                similarity_detail: c.similarity_detail || null,  // ä¿ç•™NPUçš„è©³ç´°ç›¸ä¼¼åº¦ä¿¡æ¯
                                paragraph: c.paragraph || null  // ç”¨æ–¼å‰ç«¯åˆ¤æ–·
                            });
                        } catch (err) {
                            console.warn(' è­‰æ“šç”Ÿæˆå¤±æ•—ï¼Œä½¿ç”¨æœ€å°ä¿¡æ¯å‚™æ´:', err);
                            const fallbackContent = (c && (c.sentence || c.paragraph)) || '';
                            evidences.push({
                                type: c && c.paragraph ? 'paragraph' : 'sentence',
                                page: (c && c.page) || null,
                                content: fallbackContent,
                                reasoning: 'ç³»çµ±åœ¨ç”Ÿæˆè§£é‡‹æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼Œå·²ä¿ç•™å…§å®¹èˆ‡ç›¸ä¼¼åº¦ä½œç‚ºå‚™æ´ã€‚',
                                coreHit: (c && c.coreHit) || 0,
                                kwHit: (c && c.kwHit) || 0,
                                sim: (c && c.sim) || 0,
                                analysis_level: c && c.paragraph ? 'æ®µè½ç´š' : 'å¥å­ç´š',
                                similarity_detail: (c && c.similarity_detail) || null,
                                paragraph: (c && c.paragraph) || null
                            });
                        }
                    }

                        return {
                            article: article.id,
                            articleData: article,
                            evidences,
                            analysis: analysis,
                            explanation: explanation,
                            multilevel_used: analysis !== null
                        };
                    });

                    // ç­‰å¾…ç•¶å‰æ‰¹æ¬¡æ‰€æœ‰æ¢æ–‡è™•ç†å®Œæˆ
                    const batchResults = await Promise.all(batchPromises);
                    results.push(...batchResults);
                    
                    // æ›´æ–°æ•´é«”é€²åº¦
                    const analysisProgress = 5 + (((batchIndex + 1) * BATCH_SIZE) / articles.length * 90);
                    updateProgress('analysis', Math.min(analysisProgress, 95), `æ­£åœ¨æ¯”å° ${Math.min((batchIndex + 1) * BATCH_SIZE, articles.length)} / ${articles.length} æ¢æ–‡`);
                    
                    console.log(` æ‰¹æ¬¡ ${batchIndex + 1} å®Œæˆ: ${batchResults.length}æ¢æ–‡ è™•ç†å®Œç•¢`);
                }

                updateProgress('analysis', 100, 'åˆ†æå®Œæˆ');
                overallStatusEl.textContent = 'æ­¥é©Ÿ 3/3: ç”¢ç”Ÿåˆ†æå ±å‘Š';
                updateProgress('report', 50, 'æ­£åœ¨åŒ¯ç¸½çµæœ...');
                // åœ¨æ­¤é€²è¡Œä¸€æ¬¡æ€§çµæœéæ¿¾ï¼šç§»é™¤æ²’æœ‰æœ‰æ•ˆè­‰æ“šçš„æ¢æ–‡ï¼Œç¢ºä¿å¾ŒçºŒUIä¸€è‡´
                const filteredResults = (results || []).filter(r => {
                    const evidences = r.evidences || [];
                    return evidences.length > 0 && evidences.some(ev =>
                        (ev.similarity && ev.similarity > 0.01) ||
                        (ev.sim && ev.sim > 0.01) ||
                        (ev.coreHit && ev.coreHit > 0)
                    );
                });
                console.log(`çµæœéæ¿¾ï¼š${filteredResults.length}/${(results || []).length} æ¢å«æœ‰æ•ˆè­‰æ“šçš„æ¢æ–‡å°‡é€²å…¥å ±å‘Š`);
                analysisReportData = {
                    fileName,
                    totalPages,
                    analysisDate: Date.now(),
                    results: filteredResults
                };
                try {
                    generateIFRSReport();
                    updateProgress('report', 100, 'å ±å‘Šå·²ç”Ÿæˆ');
                    overallStatusEl.textContent = 'åˆ†æå…¨éƒ¨å®Œæˆï¼';
                } catch (e) {
                    console.error(' å ±å‘Šç”Ÿæˆå¤±æ•—:', e);
                    if (loadingIndicator) loadingIndicator.style.display = 'none';
                    if (reportContainer) {
                        reportContainer.innerHTML = `
                            <div class="result-card">
                                <h2> å ±å‘Šç”Ÿæˆå¤±æ•—</h2>
                                <p>ç™¼ç”ŸéŒ¯èª¤ï¼š${(e && e.message) ? e.message : e}</p>
                                <p>è«‹é–‹å•Ÿç€è¦½å™¨æ§åˆ¶å°æŸ¥çœ‹è©³ç´°éŒ¯èª¤æ—¥èªŒã€‚</p>
                            </div>
                        `;
                    }
                }
            }

            // --- Report Generation ---
            function generateIFRSReport() {
                console.log('---  Starting Report Generation ---');
                const { fileName, totalPages, analysisDate, results } = analysisReportData;
                if (!results) {
                    console.error(' Report Generation Aborted: analysisReportData.results is missing.');
                    return;
                }
                console.log(` Found ${results.length} raw analysis results.`);

                // Filter out results with no semantic evidence (only keyword matches)
                const semanticResults = results.filter(r => {
                    const evidences = r.evidences || [];
                    // é©é…æ–°çš„è­‰æ“šçµæ§‹ï¼šæª¢æŸ¥ similarity, sim, coreHit å­—æ®µ
                    return evidences.length > 0 && evidences.some(ev => 
                        (ev.similarity && ev.similarity > 0.3) || 
                        (ev.sim && ev.sim > 0.3) || 
                        (ev.coreHit && ev.coreHit > 0)
                    );
                });

                console.log(` Found ${semanticResults.length} results with semantic evidence after filtering.`);

                // è¨ˆç®—æ•´é«”è©•åƒ¹ï¼ˆç§»é™¤å…§å®¹è¡çªæª¢æ¸¬ï¼‰
                const matchingLevels = calculateMatchingLevels(semanticResults);
                const overallEval = getOverallMatchingRating(matchingLevels);
                const categoriesAnalysis = getCategoriesAnalysis(semanticResults);
                const complianceGaps = getComplianceGaps(results, semanticResults);

                // Sort by article ID (numerical order)
                semanticResults.sort((a, b) => {
                    const aNum = parseInt(a.article.replace(/[^\d]/g, '')) || 0;
                    const bNum = parseInt(b.article.replace(/[^\d]/g, '')) || 0;
                    return aNum - bNum;
                });

                let reportHTML = `
                    <div class="result-card">
                        <h2>IFRS S1 èªç¾©åˆ†æå ±å‘Š</h2>
                        <div class="stats-grid">
                            <div class="stat-item"><div class="stat-number">${fileName}</div><div class="stat-label">åˆ†ææ–‡ä»¶</div></div>
                            <div class="stat-item"><div class="stat-number">${totalPages}</div><div class="stat-label">ç¸½é æ•¸</div></div>
                            <div class="stat-item"><div class="stat-number">${new Date(analysisDate).toLocaleString()}</div><div class="stat-label">åˆ†ææ‰€èŠ±æ™‚é–“</div></div>
                        </div>
                        <p style="font-size: 0.9rem; color: #5f6368;"> æ¢æ–‡æŒ‰ç·¨è™Ÿé †åºæ’åˆ—ï¼Œåƒ…é¡¯ç¤ºå…·èªç¾©è­‰æ“šä¹‹å…§å®¹ï¼ˆæ’é™¤ç´”é—œéµå­—åŒ¹é…ï¼‰ã€‚</p>
                        <p style="font-size: 0.9rem; color: #5f6368;"> æ¯å€‹æ¢æ–‡é¡¯ç¤ºæ ¸å¿ƒæ¦‚å¿µåŒ¹é…å’Œèªç¾©ç›¸ä¼¼åº¦è­‰æ“šï¼Œè­‰æ“šç”±AIç”Ÿæˆåˆ†æè§£é‡‹ã€‚</p>
                    </div>
                `;

                // æ–°å¢ï¼šæ•´é«”è©•åƒ¹å€å¡Šï¼ˆåˆè¦ç¨‹åº¦ã€ç¼ºé»ã€æ”¹å–„å»ºè­°ï¼Œç§»é™¤å…§å®¹è¡çªï¼‰
                const lowCategories = Object.entries(categoriesAnalysis || {})
                    .filter(([, data]) => (data && typeof data.avg_similarity === 'number' ? data.avg_similarity : 0) < 0.4)
                    .map(([name]) => name);
                const topGaps = (complianceGaps || []).slice(0, 5);

                reportHTML += `
                    <div class="result-card" style="border-left: 4px solid #1a73e8;">
                        <h2>æ•´é«”è©•åƒ¹</h2>
                        <div style="margin: 8px 0;">
                            <strong>ç¬¦åˆç¨‹åº¦ï¼š</strong>${overallEval.rating.level}ï¼ˆåŒ¹é…ç‡ ${overallEval.statistics.matchingRate}% ã€åŠ æ¬Šå¾—åˆ† ${overallEval.statistics.weightedScore}%ï¼‰
                        </div>
                        <div style="margin: 8px 0;">
                            <strong>æ•´é«”æè¿°ï¼š</strong>${overallEval.description}
                        </div>
                        <div style="margin: 8px 0;">
                            <strong>ä¸»è¦ç¼ºé» / ç¼ºå£ï¼š</strong>
                            ${topGaps.length ? (`<ul>` + topGaps.map(g => `<li>${g.article_id}ï¼š${g.title}ï¼ˆ${g.category || 'æœªåˆ†é¡'}ï¼‰â€” ${g.reason}</li>`).join('') + `</ul>`) : 'æœªç™¼ç¾æ˜é¡¯ç¼ºå£'}
                        </div>
                        <div style="margin: 8px 0;">
                            <strong>æ”¹å–„å»ºè­°ï¼š</strong>
                            <ul>
                                <li>ç¶œåˆå»ºè­°ï¼š${overallEval.recommendation}</li>
                                ${lowCategories.length ? `<li>å„ªå…ˆè£œå¼·é ˜åŸŸï¼š${lowCategories.slice(0,3).join('ã€')}ï¼ˆå¹³å‡ç›¸ä¼¼åº¦åä½ï¼‰</li>` : ''}
                                <li>é‡å°æ²»ç†ï¼šæ˜ç¢ºè‘£äº‹æœƒ/é«˜éšç®¡ç†å±¤åœ¨æ°¸çºŒè­°é¡Œä¸Šçš„è·è²¬ã€ç›£ç£æ©Ÿåˆ¶èˆ‡å ±å‘Šé »ç‡</li>
                                <li>é‡å°é¢¨éšªç®¡ç†ï¼šè£œå……é‡å¤§é¢¨éšªè­˜åˆ¥æµç¨‹ã€è©•ä¼°æ–¹æ³•ã€æ‡‰å°æ©Ÿåˆ¶èˆ‡ç›£æ¸¬æŒ‡æ¨™</li>
                                <li>é‡å°æŒ‡æ¨™èˆ‡ç›®æ¨™ï¼šæä¾›å…·é«”é‡åŒ–æŒ‡æ¨™ï¼ˆåŸºæœŸã€ç¯„ç–‡ã€é‚Šç•Œï¼‰èˆ‡å¹´åº¦/ä¸­é•·æœŸç›®æ¨™èˆ‡é€²åº¦</li>
                                <li>é‡å°å ±å‘ŠåŸºç¤ï¼šèªªæ˜å½™ç¸½å£å¾‘ã€ä¼°ç®—æ–¹æ³•ã€è³‡æ–™ä¾†æºèˆ‡å…§å¤–éƒ¨æŸ¥æ ¸æƒ…å½¢</li>
                            </ul>
                        </div>
                    </div>
                `;

                // Article cards in order
                const allArticles = ifrs1Data?.articles || [];
                allArticles.forEach(article => {
                    const articleResult = results.find(r => r.article === article.id) || {
                        article: article.id,
                        articleData: article,
                        evidences: []
                    };

                    // ç²å–æ¢æ–‡çš„æ“´å……è³‡è¨Š
                    const categoryIcon = {
                        'æ²»ç†': '',
                        'ç­–ç•¥': '', 
                        'é¢¨éšªç®¡ç†': '',
                        'æŒ‡æ¨™èˆ‡ç›®æ¨™': '',
                        'å ±å‘ŠåŸºç¤': ''
                    }[article.category] || '';
                    
                    const difficultyColor = {
                        'high': '#d32f2f',
                        'medium': '#f57c00', 
                        'low': '#388e3c'
                    }[article.difficulty] || '#666';
                    
                    reportHTML += `
                        <div class="result-card article-card">
                            <div class="article-header">
                                <h3 class="result-title">${articleResult.article}: ${article.title || 'ç„¡æ¨™é¡Œ'}</h3>
                                <div class="article-meta" style="display: flex; gap: 12px; align-items: center;">
                                    <span style="color: ${difficultyColor}; font-weight: 500;">
                                        ${categoryIcon} ${article.category || 'ä¸€èˆ¬æ¢æ–‡'}
                                    </span>
                                    <span style="color: ${difficultyColor}; font-size: 0.8rem;">
                                        é›£åº¦: ${article.difficulty === 'high' ? 'é«˜' : article.difficulty === 'medium' ? 'ä¸­' : 'ä½'}
                                    </span>
                                </div>
                            </div>
                            <div style="margin: 12px 0; padding: 12px; background: #f8f9fa; border-radius: 6px; border-left: 4px solid #4285f4;">
                                <div style="font-size: 0.9rem; color: #5f6368; line-height: 1.4;">
                                    ${(article.content || 'ç„¡å…§å®¹æ‘˜è¦').slice(0, 200)}${(article.content || '').length > 200 ? '...' : ''}
                                </div>
                                ${article.context ? `
                                    <div style="margin-top: 8px; padding: 8px; background: #e3f2fd; border-radius: 4px; font-size: 0.85rem; color: #1565c0;">
                                         ${article.context}
                                    </div>
                                ` : ''}
                                ${article.practical_guidance ? `
                                    <div style="margin-top: 8px; padding: 8px; background: #f3e5f5; border-radius: 4px; font-size: 0.85rem; color: #7b1fa2;">
                                         å¯¦å‹™æŒ‡å¼•: ${article.practical_guidance.slice(0, 100)}${article.practical_guidance.length > 100 ? '...' : ''}
                                    </div>
                                ` : ''}
                            </div>
                            ${articleResult.multilevel_used ? `
                                <div style="margin: 12px 0; padding: 12px; background: #e8f5e8; border-radius: 6px; border-left: 4px solid #34a853;">
                                    <div style="font-weight: 500; color: #1e8e3e; margin-bottom: 8px;"> å¤šå±¤ç´šèªç¾©åˆ†æ</div>
                                    ${articleResult.analysis?.max_weighted_score ? `
                                        <div style="font-size: 0.9rem; color: #2e7d32; font-weight: 500;">
                                            ç¸½é«”åŒ¹é…åº¦: ${(articleResult.analysis.max_weighted_score * 100).toFixed(1)}%
                                        </div>
                                    ` : `
                                        <div style="font-size: 0.9rem; color: #137333;">
                                            å¤šå±¤ç´šåˆ†æå·²å®Œæˆ
                                        </div>
                                    `}
                                </div>
                            ` : ''}

                            <div class="evidence-section">
                                <h4 style="margin: 16px 0 8px 0; color: #202124; font-size: 1rem;"> èªç¾©è­‰æ“šåˆ†æ</h4>
                                <div class="evidence-scrollable" style="max-height: 400px; overflow-y: auto; border: 1px solid #e8eaed; border-radius: 8px; padding: 8px;">
                                    ${articleResult.evidences && articleResult.evidences.length > 0 ? 
                                        articleResult.evidences
                                            .filter(evidence => evidence.sim > 0.03) // å¾®èª¿é–€æª»ï¼šæ”¶é›†æ›´å¤šä½ç›¸ä¼¼åº¦ä½†å¯èƒ½æœ‰åƒ¹å€¼çš„å…§å®¹
                                            .sort((a, b) => b.sim - a.sim)
                                            .slice(0, 8) // é¡¯ç¤ºå‰8å€‹æœ€ç›¸é—œçš„è­‰æ“šï¼Œå¢åŠ æ½›åœ¨ç™¼ç¾æ©Ÿæœƒ
                                            .map(evidence => `
                                                <div class="evidence-item">
                                                    <p class="evidence-text">${evidence.content || ''}</p>
                                                    ${evidence.reasoning ? `
                                                        <div class="evidence-reasoning">
                                                            <span style="color: #1e8e3e; font-weight: 500;"> AIè§£é‡‹:</span> ${evidence.reasoning}
                                                        </div>
                                                    ` : ''}
                                                    <div class="evidence-meta">
                                                        <span class="page-number">é ç¢¼: ${evidence.page || 'N/A'}</span>
                                                        ${evidence.similarity_detail ? `
                                                            <span class="similarity-level" style="
                                                                background: ${evidence.similarity_detail.colors.bg}; 
                                                                border: 1px solid ${evidence.similarity_detail.colors.border}; 
                                                                color: ${evidence.similarity_detail.colors.text};
                                                                padding: 2px 8px; 
                                                                border-radius: 12px; 
                                                                font-size: 12px; 
                                                                font-weight: 500;
                                                                display: inline-flex;
                                                                align-items: center;
                                                                gap: 3px;
                                                            ">
                                                                ${evidence.similarity_detail.colors.icon} ${evidence.similarity_detail.label} ${evidence.similarity_detail.percentage}%
                                                                <small style="opacity: 0.8;">(${evidence.analysis_level || evidence.paragraph ? 'æ®µè½ç´š' : 'å¥å­ç´š'})</small>
                                                            </span>
                                                        ` : `
                                                            <span class="similarity">ç›¸ä¼¼åº¦: ${(evidence.sim * 100).toFixed(1)}% 
                                                                <small style="opacity: 0.7;">(${evidence.analysis_level || evidence.paragraph ? 'æ®µè½ç´š' : 'å¥å­ç´š'})</small>
                                                            </span>
                                                        `}
                                                    </div>
                                                </div>
                                            `).join('')
                                        : 
                                        '<div class="no-evidence">æœªæ‰¾åˆ°ç›¸é—œè­‰æ“š</div>'
                                    }
                                </div>
                            </div>
                        </div>
                    `;
                });

                console.log(` Final report HTML generated (length: ${reportHTML.length}). Injecting into reportContainer.`);
                
                // å‰µå»ºå‚™æ´é¡¯ç¤ºæ©Ÿåˆ¶
                if (reportHTML.length < 1000) {
                    console.warn(' ç”Ÿæˆçš„å ±å‘ŠHTMLå…§å®¹éçŸ­ï¼Œå¯èƒ½æœ‰å•é¡Œ');
                    reportHTML = `
                        <div style="padding: 20px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 8px; margin: 20px 0;">
                            <h3 style="color: #b8860b;"> å ±å‘Šç”Ÿæˆè­¦å‘Š</h3>
                            <p>æª¢æ¸¬åˆ°å ±å‘Šå…§å®¹ç•°å¸¸çŸ­ (${reportHTML.length} å­—ç¬¦)ã€‚é€™å¯èƒ½æ˜¯ç”±æ–¼ï¼š</p>
                            <ul>
                                <li>ç›¸ä¼¼åº¦è¨ˆç®—è¿”å›å€¼éä½</li>
                                <li>éæ¿¾æ¢ä»¶éæ–¼åš´æ ¼</li>
                                <li>æ•¸æ“šæ ¼å¼ä¸åŒ¹é…</li>
                            </ul>
                            <p><strong>å»ºè­°ï¼š</strong>æª¢æŸ¥å¾Œç«¯APIéŸ¿æ‡‰å’Œå‰ç«¯éæ¿¾é‚è¼¯ã€‚</p>
                        </div>
                    `;
                }
                
                reportContainer.innerHTML = reportHTML;
                console.log(' Report HTML injected successfully.');
                
                // å‰µå»ºæ›´å¼·å¥çš„é¡¯ç¤ºé‚è¼¯
                function forceReportVisible() {
                    // å®Œå…¨é‡ç½®å®¹å™¨æ¨£å¼
                    reportContainer.removeAttribute('hidden');
                    reportContainer.removeAttribute('style');
                    
                    // æ‡‰ç”¨å¼·åˆ¶å¯è¦‹æ¨£å¼
                    const forceStyles = {
                        'display': 'block',
                        'visibility': 'visible',
                        'opacity': '1',
                        'position': 'relative',
                        'z-index': '100',
                        'background': 'white',
                        'border': '1px solid #e0e0e0',
                        'border-radius': '8px',
                        'padding': '20px',
                        'margin': '20px auto',
                        'min-height': '200px',
                        'max-width': '1200px',
                        'box-shadow': '0 4px 20px rgba(0,0,0,0.1)'
                    };
                    
                    Object.entries(forceStyles).forEach(([prop, value]) => {
                        reportContainer.style.setProperty(prop, value, 'important');
                    });
                    
                    // ç¢ºä¿çˆ¶å®¹å™¨éˆéƒ½å¯è¦‹
                    let parent = reportContainer.parentElement;
                    while (parent && parent !== document.body) {
                        parent.style.setProperty('display', 'block', 'important');
                        parent.style.setProperty('visibility', 'visible', 'important');
                        parent.style.setProperty('opacity', '1', 'important');
                        parent = parent.parentElement;
                    }
                    
                    return {
                        containerExists: !!reportContainer,
                        contentLength: reportContainer.innerHTML.length,
                        computedDisplay: window.getComputedStyle(reportContainer).display,
                        offsetHeight: reportContainer.offsetHeight,
                        offsetWidth: reportContainer.offsetWidth
                    };
                }
                
                // å¼·åˆ¶é¡¯ç¤ºçµæœå€åŸŸä¸¦æ»¾å‹•åˆ°è¦–åœ–
                try {
                    const debugInfo = forceReportVisible();
                    console.log(' å¼·åˆ¶é¡¯ç¤ºç‹€æ…‹:', debugInfo);
                    
                    console.log(' Report container forced visible, scrolling into view...');
                    setTimeout(() => {
                        reportContainer.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        console.log(' Scrolled to report container');
                        
                        // è¦–è¦ºæŒ‡ç¤ºå™¨å·²ç§»é™¤ - é¿å…åˆ†ææ™‚å‡ºç¾ç´…è‰²æ–¹æ ¼å¹²æ“¾
                        // å¦‚éœ€èª¿è©¦æ™‚å¯é‡æ–°å•Ÿç”¨æ­¤æŒ‡ç¤ºå™¨
                        
                    }, 300);
                } catch (e) {
                    console.warn('é¡¯ç¤ºçµæœå€åŸŸæ™‚ç™¼ç”Ÿéé—œéµéŒ¯èª¤:', e);
                }
                
                //  é¡¯ç¤ºå°å‡ºæ§åˆ¶é¢æ¿ä¸¦æ›´æ–°ä¿¡æ¯
                updateExportControls();
                
                loadingIndicator.style.display = 'none';
            }

            //  å ±å‘Šå°å‡ºåŠŸèƒ½
            function updateExportControls() {
                console.log(' æ­£åœ¨æ›´æ–°å°å‡ºæ§åˆ¶é¢æ¿...');
                
                const exportControls = document.getElementById('exportControls');
                const exportFileName = document.getElementById('exportFileName');
                const exportAnalysisDate = document.getElementById('exportAnalysisDate');
                const exportMatchCount = document.getElementById('exportMatchCount');

                if (!exportControls) {
                    console.error(' æ‰¾ä¸åˆ°å°å‡ºæ§åˆ¶é¢æ¿å…ƒç´ ');
                    return;
                }

                if (!analysisReportData || !analysisReportData.results) {
                    console.warn(' åˆ†æå ±å‘Šæ•¸æ“šä¸å­˜åœ¨ï¼Œéš±è—å°å‡ºæ§åˆ¶é¢æ¿');
                    exportControls.style.display = 'none';
                    return;
                }

                console.log(' åˆ†æå ±å‘Šæ•¸æ“šå­˜åœ¨:', analysisReportData);

                const { fileName, analysisDate, results } = analysisReportData;
                const semanticResults = results.filter(r => {
                    const evidences = r.evidences || [];
                    return evidences.length > 0 && evidences.some(ev => ev.coreHit > 0 || ev.sim > 0.01);
                });

                // å®‰å…¨æ›´æ–°UIå…ƒç´ 
                if (exportFileName) exportFileName.textContent = fileName || 'æœªçŸ¥æ–‡ä»¶';
                if (exportAnalysisDate) exportAnalysisDate.textContent = new Date(analysisDate).toLocaleString();
                if (exportMatchCount) exportMatchCount.textContent = `${semanticResults.length}/${results.length}`;
                
                exportControls.style.display = 'block';
                console.log(' å°å‡ºæ§åˆ¶é¢æ¿å·²é¡¯ç¤º');
            }

            //  èª¿è©¦åŠŸèƒ½ï¼šæª¢æŸ¥å°å‡ºåŠŸèƒ½ç‹€æ…‹
            function debugExportStatus() {
                console.log('=== å°å‡ºåŠŸèƒ½èª¿è©¦ä¿¡æ¯ ===');
                console.log('1. analysisReportData:', analysisReportData);
                console.log('2. exportControls element:', document.getElementById('exportControls'));
                console.log('3. exportFileName element:', document.getElementById('exportFileName'));
                console.log('4. exportAnalysisDate element:', document.getElementById('exportAnalysisDate'));
                console.log('5. exportMatchCount element:', document.getElementById('exportMatchCount'));
                
                const buttons = [
                    'exportReportAsHTML',
                    'exportReportAsJSON', 
                    'exportSemanticEvidence',
                    'printReport'
                ];
                
                buttons.forEach(funcName => {
                    console.log(`6. å‡½æ•¸ ${funcName} æ˜¯å¦å­˜åœ¨:`, typeof window[funcName] === 'function');
                });
                
                console.log('=== èª¿è©¦ä¿¡æ¯çµæŸ ===');
            }

            //  æ¸¬è©¦å°å‡ºåŠŸèƒ½
            function testExportFunctions() {
                console.log(' é–‹å§‹æ¸¬è©¦å°å‡ºåŠŸèƒ½...');
                
                // å‰µå»ºæ¨¡æ“¬æ•¸æ“šç”¨æ–¼æ¸¬è©¦
                const mockData = {
                    fileName: "æ¸¬è©¦æ–‡ä»¶.pdf",
                    totalPages: 10,
                    analysisDate: Date.now(),
                    results: [
                        {
                            article: "IFRS-S1-21",
                            articleData: {
                                id: "IFRS-S1-21",
                                title: "æ²»ç† - ä¸€èˆ¬è¦å®š",
                                category: "æ²»ç†",
                                difficulty: "high"
                            },
                            evidences: [
                                {
                                    type: "sentence",
                                    page: 1,
                                    content: "æ¸¬è©¦èªç¾©è­‰æ“šå…§å®¹",
                                    reasoning: "AIæ¸¬è©¦åˆ†æ",
                                    coreHit: 1,
                                    kwHit: 1,
                                    sim: 0.85,
                                    analysis_level: "å¥å­ç´š"
                                }
                            ]
                        }
                    ]
                };
                
                // æš«æ™‚è¨­ç½®æ¸¬è©¦æ•¸æ“š
                const originalData = analysisReportData;
                analysisReportData = mockData;
                
                console.log(' æ¸¬è©¦æ•¸æ“šè¨­ç½®å®Œæˆï¼Œå˜—è©¦ä¸‹è¼‰æ¸¬è©¦æª”æ¡ˆ...');
                
                // æ¸¬è©¦ä¸‹è¼‰åŠŸèƒ½
                downloadFile("æ¸¬è©¦å…§å®¹\né€™æ˜¯ä¸€å€‹æ¸¬è©¦æª”æ¡ˆ", "å°å‡ºåŠŸèƒ½æ¸¬è©¦.txt", "text/plain");
                
                // æ¢å¾©åŸå§‹æ•¸æ“š
                analysisReportData = originalData;
                
                console.log(' æ¸¬è©¦å®Œæˆ');
            }

            //  è¨ˆç®—åŒ¹é…åº¦åˆ†ç´šçµ±è¨ˆ
            function calculateMatchingLevels(results) {
                const levels = { high: 0, mediumHigh: 0, medium: 0, mediumLow: 0, low: 0 };
                
                results.forEach(result => {
                    const evidences = result.evidences || [];
                    if (evidences.length === 0) return;
                    
                    // è¨ˆç®—è©²æ¢æ–‡çš„æœ€é«˜ç›¸ä¼¼åº¦
                    const maxSimilarity = Math.max(...evidences.map(ev => ev.sim || 0));
                    
                    // æ ¹æ“šç›¸ä¼¼åº¦åˆ†ç´š
                    if (maxSimilarity >= 0.8) {
                        levels.high++;
                    } else if (maxSimilarity >= 0.6) {
                        levels.mediumHigh++;
                    } else if (maxSimilarity >= 0.4) {
                        levels.medium++;
                    } else if (maxSimilarity >= 0.2) {
                        levels.mediumLow++;
                    } else {
                        levels.low++;
                    }
                });
                
                return levels;
            }

            //  è©•ä¼°ç›¸ä¼¼åº¦ç­‰ç´š
            function getSimilarityRating(similarity) {
                if (similarity >= 0.8) return { level: 'é«˜', class: 'high', description: 'é«˜åº¦ç›¸é—œ' };
                if (similarity >= 0.6) return { level: 'ä¸­é«˜', class: 'medium-high', description: 'ç›¸ç•¶ç›¸é—œ' };
                if (similarity >= 0.4) return { level: 'ä¸­', class: 'medium', description: 'ä¸­ç­‰ç›¸é—œ' };
                if (similarity >= 0.2) return { level: 'ä¸­ä½', class: 'medium-low', description: 'è¼ƒä½ç›¸é—œ' };
                return { level: 'ä½', class: 'low', description: 'ä½åº¦ç›¸é—œ' };
            }

            //  è©•ä¼°ç¸½é«”åŒ¹é…åº¦
            function getOverallMatchingRating(levels, totalArticles = 125) {
                const totalMatched = levels.high + levels.mediumHigh + levels.medium + levels.mediumLow + levels.low;
                const matchingRate = totalMatched / totalArticles;
                
                // è¨ˆç®—åŠ æ¬Šåˆ†æ•¸ (é«˜åŒ¹é…åº¦æ¬Šé‡æ›´é«˜)
                const weightedScore = (
                    levels.high * 1.0 + 
                    levels.mediumHigh * 0.8 + 
                    levels.medium * 0.6 + 
                    levels.mediumLow * 0.4 + 
                    levels.low * 0.2
                ) / totalMatched;
                
                let rating, description, recommendation;
                
                if (matchingRate >= 0.7 && weightedScore >= 0.7) {
                    rating = { level: 'é«˜', class: 'high', score: Math.round(weightedScore * 100) };
                    description = 'ESGå ±å‘Šæ›¸èˆ‡IFRS S1æ¨™æº–é«˜åº¦åŒ¹é…';
                    recommendation = 'å ±å‘Šæ›¸å·²å……åˆ†æ»¿è¶³IFRS S1è¦æ±‚ï¼Œå»ºè­°é€²è¡Œæœ€çµ‚å¯©æ ¸';
                } else if (matchingRate >= 0.5 && weightedScore >= 0.5) {
                    rating = { level: 'ä¸­', class: 'medium', score: Math.round(weightedScore * 100) };
                    description = 'ESGå ±å‘Šæ›¸èˆ‡IFRS S1æ¨™æº–ä¸­ç­‰åŒ¹é…';
                    recommendation = 'å ±å‘Šæ›¸åŸºæœ¬ç¬¦åˆè¦æ±‚ï¼Œå»ºè­°è£œå……éƒ¨åˆ†æ¢æ–‡å…§å®¹';
                } else {
                    rating = { level: 'ä½', class: 'low', score: Math.round(weightedScore * 100) };
                    description = 'ESGå ±å‘Šæ›¸èˆ‡IFRS S1æ¨™æº–åŒ¹é…åº¦è¼ƒä½';
                    recommendation = 'å ±å‘Šæ›¸éœ€è¦å¤§å¹…æ”¹å–„ä»¥ç¬¦åˆIFRS S1è¦æ±‚';
                }
                
                return {
                    rating,
                    description,
                    recommendation,
                    statistics: {
                        totalMatched,
                        matchingRate: Math.round(matchingRate * 100),
                        weightedScore: Math.round(weightedScore * 100)
                    }
                };
            }

            // ç§»é™¤detectContentConflictså‡½æ•¸

            // åœ¨é é¢åŠ è¼‰å®Œæˆå¾Œï¼Œå°‡èª¿è©¦å’Œå°å‡ºå‡½æ•¸æš´éœ²åˆ°å…¨å±€
            window.debugExportStatus = debugExportStatus;
            window.testExportFunctions = testExportFunctions;
            window.exportReportAsHTML = exportReportAsHTML;
            window.exportReportAsJSON = exportReportAsJSON;
            window.exportSemanticEvidence = exportSemanticEvidence;
            window.printReport = printReport;
            window.previewReportAsHTML = previewReportAsHTML;
            window.downloadReportAsHTML = downloadReportAsHTML;
            window.calculateMatchingLevels = calculateMatchingLevels;
            window.getSimilarityRating = getSimilarityRating;
            window.getOverallMatchingRating = getOverallMatchingRating;

            //  å°å‡ºå®Œæ•´HTMLå ±å‘Š
            function exportReportAsHTML() {
                console.log(' é–‹å§‹å°å‡ºHTMLå ±å‘Š...');
                
                if (!analysisReportData) {
                    console.error(' æ²’æœ‰åˆ†æå ±å‘Šæ•¸æ“š');
                    alert('æ²’æœ‰å¯å°å‡ºçš„å ±å‘Šæ•¸æ“šï¼Œè«‹å…ˆå®ŒæˆPDFåˆ†æ');
                    return;
                }

                console.log(' åˆ†æå ±å‘Šæ•¸æ“šæª¢æŸ¥é€šéï¼Œé–‹å§‹ç”ŸæˆHTML...');

                const { fileName, totalPages, analysisDate, results } = analysisReportData;
                const semanticResults = results.filter(r => {
                    const evidences = r.evidences || [];
                    return evidences.length > 0 && evidences.some(ev => ev.coreHit > 0 || ev.sim > 0.01);
                });
                
                // è¨ˆç®—åŒ¹é…åº¦åˆ†ç´š
                const matchingLevels = calculateMatchingLevels(semanticResults);
                
                // è¨ˆç®—ç¸½é«”è©•åƒ¹
                const overallRating = getOverallMatchingRating(matchingLevels);

                let fullReportHTML = `
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IFRS S1 èªç¾©åˆ†æå ±å‘Š - ${fileName}</title>
    <style>
        body { font-family: 'Microsoft JhengHei', sans-serif; line-height: 1.6; margin: 20px; }
        .header { text-align: center; border-bottom: 2px solid #4285f4; padding-bottom: 20px; margin-bottom: 30px; }
        .stats-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin: 20px 0; }
        .matching-levels { display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; margin: 20px 0; }
        .level-item { text-align: center; padding: 10px; border-radius: 6px; }
        .level-high { background: #e8f5e8; border: 2px solid #4caf50; }
        .level-medium-high { background: #fff3e0; border: 2px solid #ff9800; }
        .level-medium { background: #e3f2fd; border: 2px solid #2196f3; }
        .level-medium-low { background: #fce4ec; border: 2px solid #e91e63; }
        .level-low { background: #ffebee; border: 2px solid #f44336; }
        .overall-rating { margin: 30px 0; padding: 25px; border-radius: 12px; border-left: 6px solid; }
        .rating-high { background: #e8f5e8; border-color: #4caf50; }
        .rating-medium { background: #e3f2fd; border-color: #2196f3; }
        .rating-low { background: #ffebee; border-color: #f44336; }
        .rating-badge { display: inline-block; padding: 8px 16px; border-radius: 20px; color: white; font-weight: bold; margin-right: 15px; }
        .badge-high { background: #4caf50; }
        .badge-medium { background: #2196f3; }
        .badge-low { background: #f44336; }
        .similarity-rating { margin: 5px 0; padding: 5px 10px; border-radius: 15px; font-size: 0.85em; display: inline-block; }
        .sim-high { background: #e8f5e8; color: #2e7d32; border: 1px solid #4caf50; }
        .sim-medium-high { background: #fff3e0; color: #ef6c00; border: 1px solid #ff9800; }
        .sim-medium { background: #e3f2fd; color: #1565c0; border: 1px solid #2196f3; }
        .sim-medium-low { background: #fce4ec; color: #c2185b; border: 1px solid #e91e63; }
        .sim-low { background: #ffebee; color: #d32f2f; border: 1px solid #f44336; }
        .stat-item { text-align: center; padding: 15px; background: #f8f9fa; border-radius: 8px; }
        .stat-number { font-size: 1.5em; font-weight: bold; color: #4285f4; }
        .stat-label { color: #666; margin-top: 5px; }
        .article-card { margin: 20px 0; padding: 20px; border: 1px solid #ddd; border-radius: 8px; }
        .article-title { color: #4285f4; font-weight: bold; margin-bottom: 10px; }
        .evidence-item { margin: 15px 0; padding: 15px; background: #f9f9f9; border-left: 4px solid #4285f4; }
        .evidence-meta { font-size: 0.9em; color: #666; margin-bottom: 10px; }
        .evidence-content { margin: 10px 0; padding: 10px; background: white; border-radius: 4px; }
        .similarity-score { font-weight: bold; color: #34a853; }
        @media print { .no-print { display: none; } }
    </style>
</head>
<body>
    <div class="header">
        <h1>IFRS S1 èªç¾©åˆ†æå ±å‘Š</h1>
        <p>ç”Ÿæˆæ™‚é–“: ${new Date().toLocaleString()}</p>
    </div>
    
    <div class="stats-grid">
        <div class="stat-item"><div class="stat-number">${fileName}</div><div class="stat-label">åˆ†ææ–‡ä»¶</div></div>
        <div class="stat-item"><div class="stat-number">${totalPages}</div><div class="stat-label">ç¸½é æ•¸</div></div>
        <div class="stat-item"><div class="stat-number">${semanticResults.length}</div><div class="stat-label">åŒ¹é…æ¢æ–‡æ•¸</div></div>
    </div>
    
    <div class="matching-levels">
        <div class="level-item level-high">
            <div class="stat-number">${matchingLevels.high}</div>
            <div class="stat-label">é«˜ (â‰¥80%)</div>
        </div>
        <div class="level-item level-medium-high">
            <div class="stat-number">${matchingLevels.mediumHigh}</div>
            <div class="stat-label">ä¸­é«˜ (60-79%)</div>
        </div>
        <div class="level-item level-medium">
            <div class="stat-number">${matchingLevels.medium}</div>
            <div class="stat-label">ä¸­ (40-59%)</div>
        </div>
        <div class="level-item level-medium-low">
            <div class="stat-number">${matchingLevels.mediumLow}</div>
            <div class="stat-label">ä¸­ä½ (20-39%)</div>
        </div>
        <div class="level-item level-low">
            <div class="stat-number">${matchingLevels.low}</div>
            <div class="stat-label">ä½ (<20%)</div>
        </div>
    </div>
    
    <div class="overall-rating rating-${overallRating.rating.class}">
        <h3 style="margin-top: 0; display: flex; align-items: center;">
            <span class="rating-badge badge-${overallRating.rating.class}">ç¸½é«”åŒ¹é…åº¦ï¼š${overallRating.rating.level}</span>
            <span style="font-size: 1.2em; font-weight: bold;">åˆ†æ•¸ï¼š${overallRating.rating.score}åˆ†</span>
        </h3>
        <p style="font-size: 1.1em; margin: 15px 0;"><strong>${overallRating.description}</strong></p>
        <p style="margin: 10px 0;"> <strong>å°ˆæ¥­å»ºè­°ï¼š</strong>${overallRating.recommendation}</p>
        <div style="margin-top: 15px; font-size: 0.9em; color: #666;">
            <span style="margin-right: 20px;"> æ¢æ–‡åŒ¹é…ç‡ï¼š${overallRating.statistics.matchingRate}%</span>
            <span style="margin-right: 20px;"> åŠ æ¬Šå¾—åˆ†ï¼š${overallRating.statistics.weightedScore}%</span>
            <span> å·²åŒ¹é…æ¢æ–‡ï¼š${overallRating.statistics.totalMatched}/125</span>
        </div>
    </div>
`;

                semanticResults.forEach(result => {
                    const { articleData, evidences } = result;
                    fullReportHTML += `
    <div class="article-card">
        <div class="article-title">${articleData.id}: ${articleData.title}</div>
        <p><strong>é¡åˆ¥:</strong> ${articleData.category} | <strong>é›£åº¦:</strong> ${articleData.difficulty}</p>
        <p><strong>å…§å®¹:</strong> ${articleData.content}</p>
        
        <h4>èªç¾©è­‰æ“šåˆ†æ</h4>`;

                    evidences.forEach((evidence, index) => {
                        // é©é…æ–°çš„ç›¸ä¼¼åº¦å­—æ®µçµæ§‹
                        const similarityValue = evidence.similarity || evidence.sim || 0;
                        const simRating = getSimilarityRating(similarityValue);
                        fullReportHTML += `
        <div class="evidence-item">
            <div class="evidence-meta">
                 é æ•¸: ${evidence.page || 1} |  é¡å‹: ${evidence.type || evidence.analysis_level || 'unknown'} | 
                <span class="similarity-score">ç›¸ä¼¼åº¦: ${(similarityValue * 100).toFixed(1)}%</span>
                <span class="similarity-rating sim-${simRating.class}">${simRating.level} - ${simRating.description}</span>
            </div>
            <div class="evidence-content">
                <strong>æ–‡æœ¬å…§å®¹:</strong><br>
                ${evidence.content}
            </div>
            <div class="evidence-content">
                <strong>AIåˆ†æ:</strong><br>
                ${evidence.reasoning}
            </div>
        </div>`;
                    });

                    fullReportHTML += `
    </div>`;
                });

                fullReportHTML += `
    <div class="no-print" style="margin-top: 40px; padding: 20px; background: #f0f8ff; border-radius: 8px;">
        <p><strong>å ±å‘Šèªªæ˜:</strong></p>
        <ul>
            <li>æœ¬å ±å‘ŠåŸºæ–¼IFRS S1æ°¸çºŒç›¸é—œè²¡å‹™è³‡è¨Šæ­éœ²æ¨™æº–é€²è¡Œèªç¾©åˆ†æ</li>
            <li>åƒ…é¡¯ç¤ºå…·æœ‰èªç¾©è­‰æ“šçš„æ¢æ–‡åŒ¹é…çµæœ</li>
            <li>ç›¸ä¼¼åº¦åˆ†æ•¸åŸºæ–¼é›™æ¨¡å‹èåˆç®—æ³•è¨ˆç®—</li>
            <li>AIåˆ†æè§£é‡‹ç”±å…ˆé€²çš„èªè¨€æ¨¡å‹ç”Ÿæˆ</li>
        </ul>
    </div>
</body>
</html>`;

                downloadFile(fullReportHTML, `IFRS_S1_åˆ†æå ±å‘Š_${fileName}_${new Date().toISOString().split('T')[0]}.html`, 'text/html');
            }

            //  å°å‡ºåˆ†ææ•¸æ“šç‚ºJSON
            function exportReportAsJSON() {
                console.log(' é–‹å§‹å°å‡ºJSONæ•¸æ“š...');
                
                if (!analysisReportData) {
                    console.error(' æ²’æœ‰åˆ†æå ±å‘Šæ•¸æ“š');
                    alert('æ²’æœ‰å¯å°å‡ºçš„åˆ†ææ•¸æ“šï¼Œè«‹å…ˆå®ŒæˆPDFåˆ†æ');
                    return;
                }

                console.log(' åˆ†æå ±å‘Šæ•¸æ“šæª¢æŸ¥é€šéï¼Œé–‹å§‹ç”ŸæˆJSON...');

                const exportData = {
                    metadata: {
                        fileName: analysisReportData.fileName,
                        totalPages: analysisReportData.totalPages,
                        analysisDate: analysisReportData.analysisDate,
                        exportDate: new Date().toISOString(),
                        tool: "IFRS S1 ESG å ±å‘Šåˆ†æå·¥å…· v6.0",
                        model: "dual-gemma-qwen3-fused"
                    },
                    statistics: {
                        totalArticles: analysisReportData.results.length,
                        semanticMatches: analysisReportData.results.filter(r => {
                            const evidences = r.evidences || [];
                            return evidences.length > 0 && evidences.some(ev => ev.coreHit > 0 || ev.sim > 0.01);
                        }).length
                    },
                    results: analysisReportData.results.map(result => ({
                        article: {
                            id: result.articleData.id,
                            title: result.articleData.title,
                            category: result.articleData.category,
                            difficulty: result.articleData.difficulty,
                            content: result.articleData.content,
                            keywords: result.articleData.keywords
                        },
                        analysis: result.analysis,
                        evidences: result.evidences.map(evidence => ({
                            page: evidence.page,
                            type: evidence.type,
                            analysisLevel: evidence.analysis_level,
                            content: evidence.content,
                            reasoning: evidence.reasoning,
                            similarity: evidence.sim,
                            coreConceptHits: evidence.coreHit,
                            keywordHits: evidence.kwHit,
                            similarityDetail: evidence.similarity_detail
                        }))
                    }))
                };

                const jsonString = JSON.stringify(exportData, null, 2);
                downloadFile(jsonString, `IFRS_S1_åˆ†ææ•¸æ“š_${analysisReportData.fileName}_${new Date().toISOString().split('T')[0]}.json`, 'application/json');
            }

            //  å°å‡ºèªç¾©è­‰æ“šåˆ†æ
            function exportSemanticEvidence() {
                console.log(' é–‹å§‹å°å‡ºèªç¾©è­‰æ“š...');
                
                if (!analysisReportData) {
                    console.error(' æ²’æœ‰åˆ†æå ±å‘Šæ•¸æ“š');
                    alert('æ²’æœ‰å¯å°å‡ºçš„èªç¾©è­‰æ“šï¼Œè«‹å…ˆå®ŒæˆPDFåˆ†æ');
                    return;
                }

                console.log(' åˆ†æå ±å‘Šæ•¸æ“šæª¢æŸ¥é€šéï¼Œé–‹å§‹ç”Ÿæˆèªç¾©è­‰æ“šå ±å‘Š...');

                const { fileName, results } = analysisReportData;
                const semanticResults = results.filter(r => {
                    const evidences = r.evidences || [];
                    return evidences.length > 0 && evidences.some(ev => ev.coreHit > 0 || ev.sim > 0.01);
                });

                let evidenceReport = `IFRS S1 èªç¾©è­‰æ“šåˆ†æå ±å‘Š\n`;
                evidenceReport += `æ–‡ä»¶: ${fileName}\n`;
                evidenceReport += `ç”Ÿæˆæ™‚é–“: ${new Date().toLocaleString()}\n`;
                evidenceReport += `åŒ¹é…æ¢æ–‡: ${semanticResults.length}å€‹\n`;
                evidenceReport += `${'='.repeat(60)}\n\n`;

                semanticResults.forEach((result, index) => {
                    const { articleData, evidences } = result;
                    evidenceReport += `${index + 1}. ${articleData.id}: ${articleData.title}\n`;
                    evidenceReport += `   é¡åˆ¥: ${articleData.category} | é›£åº¦: ${articleData.difficulty}\n`;
                    evidenceReport += `   å…§å®¹: ${articleData.content}\n\n`;
                    
                    evidenceReport += `   èªç¾©è­‰æ“š (${evidences.length}é …):\n`;
                    evidences.forEach((evidence, evidenceIndex) => {
                        evidenceReport += `   ${evidenceIndex + 1}. [é ${evidence.page}] ${evidence.analysis_level} (ç›¸ä¼¼åº¦: ${(evidence.sim * 100).toFixed(1)}%)\n`;
                        evidenceReport += `      æ–‡æœ¬: ${evidence.content}\n`;
                        evidenceReport += `      åˆ†æ: ${evidence.reasoning}\n`;
                        if (evidence.similarity_detail) {
                            evidenceReport += `      è©³ç´°: ${evidence.similarity_detail.label} ${evidence.similarity_detail.percentage}%\n`;
                        }
                        evidenceReport += `\n`;
                    });
                    evidenceReport += `${'-'.repeat(50)}\n\n`;
                });

                evidenceReport += `å ±å‘Šèªªæ˜:\n`;
                evidenceReport += `- æœ¬å ±å‘ŠåŒ…å«æ‰€æœ‰å…·èªç¾©è­‰æ“šçš„IFRS S1æ¢æ–‡åŒ¹é…\n`;
                evidenceReport += `- ç›¸ä¼¼åº¦åˆ†æ•¸åŸºæ–¼é›™æ¨¡å‹èåˆèªç¾©åˆ†æ\n`;
                evidenceReport += `- AIåˆ†æè§£é‡‹æä¾›ä¸Šä¸‹æ–‡ç†è§£\n`;

                downloadFile(evidenceReport, `IFRS_S1_èªç¾©è­‰æ“š_${fileName}_${new Date().toISOString().split('T')[0]}.txt`, 'text/plain');
            }

            //  åˆ—å°å ±å‘Š
            function printReport() {
                if (!analysisReportData) {
                    alert('æ²’æœ‰å¯åˆ—å°çš„å ±å‘Š');
                    return;
                }

                // å‰µå»ºåˆ—å°çª—å£
                const printWindow = window.open('', '_blank');
                const reportContent = document.getElementById('reportContainer').innerHTML;
                
                printWindow.document.write(`
<!DOCTYPE html>
<html>
<head>
    <title>IFRS S1 åˆ†æå ±å‘Š - ${analysisReportData.fileName}</title>
    <style>
        body { font-family: 'Microsoft JhengHei', sans-serif; line-height: 1.6; margin: 20px; }
        .result-card { margin-bottom: 20px; }
        .stats-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin: 20px 0; }
        .stat-item { text-align: center; padding: 10px; background: #f8f9fa; border-radius: 4px; }
        .evidence-block { margin: 15px 0; padding: 15px; border: 1px solid #ddd; border-radius: 8px; }
        .similarity-level { display: inline-block; padding: 2px 6px; border-radius: 4px; font-size: 0.8em; }
        @page { margin: 1in; }
        @media print { 
            body { font-size: 12px; }
            .no-print { display: none; }
        }
    </style>
</head>
<body>
    ${reportContent}
    <div style="margin-top: 30px; font-size: 0.9em; color: #666;">
        åˆ—å°æ™‚é–“: ${new Date().toLocaleString()}
    </div>
</body>
</html>`);
                
                printWindow.document.close();
                printWindow.focus();
                
                // å»¶é²åˆ—å°ä»¥ç¢ºä¿å…§å®¹è¼‰å…¥å®Œæˆ
                setTimeout(() => {
                    printWindow.print();
                    printWindow.close();
                }, 500);
            }

            //  å°å‡ºPDFå ±å‘Š
            function previewReportAsHTML() {
                console.log(' é–‹å§‹HTMLé è¦½å ±å‘Š...');
                
                if (!analysisReportData) {
                    console.error(' æ²’æœ‰åˆ†æå ±å‘Šæ•¸æ“š');
                    alert('æ²’æœ‰å¯å°å‡ºçš„å ±å‘Šæ•¸æ“šï¼Œè«‹å…ˆå®ŒæˆPDFåˆ†æ');
                    return;
                }

                const { fileName, totalPages, analysisDate, results } = analysisReportData;
                const semanticResults = results.filter(r => {
                    const evidences = r.evidences || [];
                    return evidences.length > 0 && evidences.some(ev => ev.coreHit > 0 || ev.sim > 0.01);
                });
                
                // è¨ˆç®—åŒ¹é…åº¦åˆ†ç´š
                const matchingLevels = calculateMatchingLevels(semanticResults);
                
                // è¨ˆç®—ç¸½é«”è©•åƒ¹
                const overallRating = getOverallMatchingRating(matchingLevels);

                // å‰µå»ºæ–°çª—å£ç”¨æ–¼PDFç”Ÿæˆ
                const pdfWindow = window.open('', '_blank');
                
                const pdfHTML = `
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IFRS S1 ESGå ±å‘Šåˆ†æ - ${fileName}</title>
    <style>
        @page {
            margin: 20mm;
            size: A4;
            @bottom-right {
                content: "æ­¤å ±å‘Šç”±AIç”Ÿæˆï¼Œä½œè€…ï¼šæ¸¸å£«å¼˜";
                font-size: 10px;
                color: #666;
                margin-right: 5mm;
                margin-bottom: 5mm;
            }
        }
        
        body { 
            font-family: 'Microsoft JhengHei', 'PingFang TC', 'Microsoft YaHei', sans-serif; 
            line-height: 1.6; 
            margin: 0; 
            padding: 20px;
            color: #333;
        }
        
        .header { 
            text-align: center; 
            border-bottom: 3px solid #1a73e8; 
            padding-bottom: 20px; 
            margin-bottom: 30px; 
            page-break-after: avoid;
        }
        
        .header h1 {
            color: #1a73e8;
            font-size: 28px;
            margin-bottom: 10px;
        }
        
        .header-info {
            color: #666;
            font-size: 14px;
        }
        
        .stats-grid { 
            display: grid; 
            grid-template-columns: repeat(3, 1fr); 
            gap: 15px; 
            margin: 20px 0; 
            page-break-inside: avoid;
        }
        
        .matching-levels { 
            display: grid; 
            grid-template-columns: repeat(5, 1fr); 
            gap: 8px; 
            margin: 15px 0; 
            page-break-inside: avoid;
        }
        
        .level-item { 
            text-align: center; 
            padding: 8px; 
            border-radius: 5px;
            font-size: 12px;
        }
        
        .level-high { background: #e8f5e8; border: 1px solid #4caf50; }
        .level-medium-high { background: #fff3e0; border: 1px solid #ff9800; }
        .level-medium { background: #e3f2fd; border: 1px solid #2196f3; }
        .level-medium-low { background: #fce4ec; border: 1px solid #e91e63; }
        .level-low { background: #ffebee; border: 1px solid #f44336; }
        
        .overall-rating { 
            margin: 25px 0; 
            padding: 20px; 
            border-radius: 10px; 
            border-left: 5px solid;
            page-break-inside: avoid;
        }
        .rating-high { background: #e8f5e8; border-color: #4caf50; }
        .rating-medium { background: #e3f2fd; border-color: #2196f3; }
        .rating-low { background: #ffebee; border-color: #f44336; }
        .rating-badge { 
            display: inline-block; 
            padding: 6px 12px; 
            border-radius: 15px; 
            color: white; 
            font-weight: bold; 
            margin-right: 10px;
            font-size: 14px;
        }
        .badge-high { background: #4caf50; }
        .badge-medium { background: #2196f3; }
        .badge-low { background: #f44336; }
        .similarity-rating { 
            margin: 3px 5px; 
            padding: 3px 8px; 
            border-radius: 10px; 
            font-size: 11px; 
            display: inline-block;
        }
        .sim-high { background: #e8f5e8; color: #2e7d32; border: 1px solid #4caf50; }
        .sim-medium-high { background: #fff3e0; color: #ef6c00; border: 1px solid #ff9800; }
        .sim-medium { background: #e3f2fd; color: #1565c0; border: 1px solid #2196f3; }
        .sim-medium-low { background: #fce4ec; color: #c2185b; border: 1px solid #e91e63; }
        .sim-low { background: #ffebee; color: #d32f2f; border: 1px solid #f44336; }
        
        .stat-item { 
            text-align: center; 
            padding: 15px; 
            background: #f8f9fa; 
            border-radius: 8px; 
            border: 1px solid #e0e0e0;
        }
        
        .stat-number { 
            font-size: 20px; 
            font-weight: bold; 
            color: #1a73e8; 
            margin-bottom: 5px;
        }
        
        .stat-label { 
            color: #666; 
            font-size: 14px;
        }
        
        .article-card { 
            margin: 25px 0; 
            padding: 20px; 
            border: 2px solid #e0e0e0; 
            border-radius: 10px; 
            page-break-inside: avoid;
            background: #fafafa;
        }
        
        .article-title { 
            color: #1a73e8; 
            font-weight: bold; 
            font-size: 16px;
            margin-bottom: 10px; 
        }
        
        .article-meta {
            background: #fff;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            border-left: 4px solid #1a73e8;
        }
        
        .evidence-section {
            margin-top: 20px;
        }
        
        .evidence-item { 
            margin: 15px 0; 
            padding: 15px; 
            background: #fff; 
            border-left: 4px solid #34a853; 
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .evidence-meta { 
            font-size: 12px; 
            color: #666; 
            margin-bottom: 10px; 
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .evidence-content { 
            margin: 10px 0; 
            padding: 12px; 
            background: #f9f9f9; 
            border-radius: 5px; 
            font-size: 14px;
            line-height: 1.5;
        }
        
        .similarity-score { 
            font-weight: bold; 
            color: #34a853; 
            background: #e8f5e8;
            padding: 2px 8px;
            border-radius: 12px;
        }
        
        .footer-signature {
            position: fixed;
            bottom: 10mm;
            right: 15mm;
            font-size: 10px;
            color: #666;
            text-align: right;
        }
        
        .page-break {
            page-break-after: always;
        }
        
        @media print { 
            .no-print { display: none; }
            body { font-size: 12px; }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>IFRS S1 ESGå ±å‘Šåˆ†æ</h1>
        <div class="header-info">
            <p>åŸºæ–¼æ°¸çºŒç›¸é—œè²¡å‹™è³‡è¨Šæ­éœ²æ¨™æº–çš„æ™ºæ…§åˆ†æå ±å‘Š</p>
            <p>ç”Ÿæˆæ™‚é–“ï¼š${new Date().toLocaleString()}</p>
        </div>
    </div>
    
    <div class="stats-grid">
        <div class="stat-item">
            <div class="stat-number">${fileName}</div>
            <div class="stat-label">åˆ†ææ–‡ä»¶</div>
        </div>
        <div class="stat-item">
            <div class="stat-number">${totalPages}</div>
            <div class="stat-label">ç¸½é æ•¸</div>
        </div>
        <div class="stat-item">
            <div class="stat-number">${semanticResults.length}</div>
            <div class="stat-label">åŒ¹é…æ¢æ–‡æ•¸</div>
        </div>
    </div>
    
    <div class="matching-levels">
        <div class="level-item level-high">
            <div class="stat-number">${matchingLevels.high}</div>
            <div class="stat-label">é«˜ (â‰¥80%)</div>
        </div>
        <div class="level-item level-medium-high">
            <div class="stat-number">${matchingLevels.mediumHigh}</div>
            <div class="stat-label">ä¸­é«˜ (60-79%)</div>
        </div>
        <div class="level-item level-medium">
            <div class="stat-number">${matchingLevels.medium}</div>
            <div class="stat-label">ä¸­ (40-59%)</div>
        </div>
        <div class="level-item level-medium-low">
            <div class="stat-number">${matchingLevels.mediumLow}</div>
            <div class="stat-label">ä¸­ä½ (20-39%)</div>
        </div>
        <div class="level-item level-low">
            <div class="stat-number">${matchingLevels.low}</div>
            <div class="stat-label">ä½ (<20%)</div>
        </div>
    </div>
    
    <div class="overall-rating rating-${overallRating.rating.class}">
        <h3 style="margin-top: 0; display: flex; align-items: center; flex-wrap: wrap;">
            <span class="rating-badge badge-${overallRating.rating.class}">ç¸½é«”åŒ¹é…åº¦ï¼š${overallRating.rating.level}</span>
            <span style="font-size: 16px; font-weight: bold; margin-left: 10px;">åˆ†æ•¸ï¼š${overallRating.rating.score}åˆ†</span>
        </h3>
        <p style="font-size: 15px; margin: 12px 0; line-height: 1.5;"><strong>${overallRating.description}</strong></p>
        <p style="margin: 8px 0; font-size: 14px;"><strong> å°ˆæ¥­å»ºè­°ï¼š</strong>${overallRating.recommendation}</p>
        <div style="margin-top: 12px; font-size: 12px; color: #666; line-height: 1.4;">
            <div style="margin-bottom: 4px;"> æ¢æ–‡åŒ¹é…ç‡ï¼š${overallRating.statistics.matchingRate}% |  åŠ æ¬Šå¾—åˆ†ï¼š${overallRating.statistics.weightedScore}% |  å·²åŒ¹é…æ¢æ–‡ï¼š${overallRating.statistics.totalMatched}/125</div>
        </div>
    </div>
`;

                semanticResults.forEach((result, index) => {
                    const { articleData, evidences } = result;
                    pdfHTML += `
    <div class="article-card">
        <div class="article-title">${articleData.id}: ${articleData.title}</div>
        <div class="article-meta">
            <p><strong>é¡åˆ¥ï¼š</strong>${articleData.category} | <strong>é›£åº¦ï¼š</strong>${articleData.difficulty}</p>
            <p><strong>æ¢æ–‡å…§å®¹ï¼š</strong>${articleData.content}</p>
        </div>
        
        <div class="evidence-section">
            <h4 style="color: #1a73e8; margin-bottom: 15px;"> èªç¾©è­‰æ“šåˆ†æ</h4>`;

                    evidences.forEach((evidence, evidenceIndex) => {
                        // é©é…æ–°çš„ç›¸ä¼¼åº¦å­—æ®µçµæ§‹
                        const similarityValue = evidence.similarity || evidence.sim || 0;
                        const simRating = getSimilarityRating(similarityValue);
                        pdfHTML += `
            <div class="evidence-item">
                <div class="evidence-meta">
                    <span> é æ•¸ï¼š${evidence.page} |  åˆ†æå±¤ç´šï¼š${evidence.analysis_level}</span>
                    <span class="similarity-score">ç›¸ä¼¼åº¦ï¼š${(evidence.sim * 100).toFixed(1)}%</span>
                    <span class="similarity-rating sim-${simRating.class}">${simRating.level}</span>
                </div>
                <div class="evidence-content">
                    <strong>æ–‡æœ¬å…§å®¹ï¼š</strong><br>
                    ${evidence.content}
                </div>
                <div class="evidence-content">
                    <strong>AIæ™ºæ…§åˆ†æï¼š</strong><br>
                    ${evidence.reasoning}
                </div>
            </div>`;
                    });

                    pdfHTML += `
        </div>
    </div>`;
                    
                    // æ¯3å€‹æ¢æ–‡å¾Œåˆ†é ï¼Œé¿å…å…§å®¹éæ–¼å¯†é›†
                    if ((index + 1) % 3 === 0 && index < semanticResults.length - 1) {
                        pdfHTML += '<div class="page-break"></div>';
                    }
                });

                pdfHTML += `
    <div style="margin-top: 40px; padding: 20px; background: #f0f8ff; border-radius: 8px; border: 1px solid #1a73e8;">
        <h3 style="color: #1a73e8; margin-top: 0;"> å ±å‘Šèªªæ˜</h3>
        <ul style="line-height: 1.8;">
            <li>æœ¬å ±å‘ŠåŸºæ–¼ IFRS S1 æ°¸çºŒç›¸é—œè²¡å‹™è³‡è¨Šæ­éœ²æ¨™æº–é€²è¡Œæ™ºæ…§èªç¾©åˆ†æ</li>
            <li>æ¡ç”¨é›™æ¨¡å‹èåˆæ¶æ§‹ï¼ˆEmbeddingGemma + Qwen3ï¼‰é€²è¡Œç²¾æº–èªç¾©åŒ¹é…</li>
            <li>é‹ç”¨ FAISS å‘é‡æª¢ç´¢æŠ€è¡“æå‡åˆ†ææ•ˆç‡</li>
            <li>åˆ†ææ¶µè“‹æ²»ç†ã€ç­–ç•¥ã€é¢¨éšªç®¡ç†ã€æŒ‡æ¨™èˆ‡ç›®æ¨™ç­‰å››å¤§æ ¸å¿ƒé ˜åŸŸ</li>
            <li>ç›¸ä¼¼åº¦è¨ˆç®—åŸºæ–¼èªç¾©ç†è§£ï¼Œéå–®ç´”é—œéµè©åŒ¹é…</li>
        </ul>
        <p style="margin-bottom: 0; color: #666; font-size: 14px;">
            <strong>æŠ€è¡“æ¶æ§‹ï¼š</strong>é›™æ¨¡å‹èåˆ + FAISSåŠ é€Ÿæª¢ç´¢ + èªç¾©æ˜ å°„ç³»çµ±
        </p>
    </div>
    
    <div class="footer-signature">
        æ­¤å ±å‘Šç”±AIç”Ÿæˆï¼Œä½œè€…ï¼šæ¸¸å£«å¼˜
    </div>
</body>
</html>`;

                pdfWindow.document.write(pdfHTML);
                pdfWindow.document.close();

                // ç­‰å¾…å…§å®¹è¼‰å…¥å®Œæˆå¾Œè§¸ç™¼åˆ—å°
                setTimeout(() => {
                    pdfWindow.focus();
                    pdfWindow.print();
                    
                    // åˆ—å°å¾Œé—œé–‰çª—å£
                    pdfWindow.addEventListener('afterprint', () => {
                        pdfWindow.close();
                    });
                }, 1000);

                console.log(' HTMLé è¦½çª—å£å·²é–‹å•Ÿï¼Œè«‹é¸æ“‡"å¦å­˜ç‚ºPDF"é€²è¡Œä¸‹è¼‰');
            }

            // HTMLå ±å‘Šä¸‹è¼‰åŠŸèƒ½
            function downloadReportAsHTML() {
                console.log(' é–‹å§‹ç”ŸæˆHTMLå ±å‘Š...');
                
                if (!analysisReportData) {
                    console.error(' æ²’æœ‰åˆ†æå ±å‘Šæ•¸æ“š');
                    alert('æ²’æœ‰å¯å°å‡ºçš„å ±å‘Šæ•¸æ“šï¼Œè«‹å…ˆå®Œæˆåˆ†æ');
                    return;
                }

                const { fileName, totalPages, analysisDate, results } = analysisReportData;
                const semanticResults = results.filter(r => {
                    const evidences = r.evidences || [];
                    return evidences.length > 0 && evidences.some(ev => 
                        (ev.similarity && ev.similarity > 0.3) || 
                        (ev.sim && ev.sim > 0.3) || 
                        (ev.coreHit && ev.coreHit > 0)
                    );
                });
                
                // è¨ˆç®—åŒ¹é…åº¦åˆ†ç´š
                const matchingLevels = calculateMatchingLevels(semanticResults);
                
                // è¨ˆç®—ç¸½é«”è©•åƒ¹
                const overallRating = getOverallMatchingRating(matchingLevels);

                // ç”ŸæˆHTMLå…§å®¹
                const htmlContent = generateHTMLContent(fileName, totalPages, semanticResults, matchingLevels, overallRating);

                // å‰µå»ºä¸¦ä¸‹è¼‰HTMLæ–‡ä»¶
                const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `IFRS_S1_åˆ†æå ±å‘Š_${fileName.replace(/\.pdf$/i, '')}.html`;
                
                // è§¸ç™¼ä¸‹è¼‰
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // æ¸…ç†URLå°è±¡
                URL.revokeObjectURL(url);
                
                console.log(' HTMLå ±å‘Šå·²ç”Ÿæˆä¸¦ä¸‹è¼‰');
            }

            // PDFå…§å®¹ç”Ÿæˆå‡½æ•¸
            function generatePDFContent(fileName, totalPages, semanticResults, matchingLevels, overallRating) {
                const currentDate = new Date().toLocaleString();
                
                let htmlContent = `
                    <div style="text-align: center; margin-bottom: 30px; border-bottom: 2px solid #1976d2; padding-bottom: 20px;">
                        <h1 style="color: #1976d2; margin: 0; font-size: 24px;">IFRS S1 ESGå ±å‘Šåˆ†æ</h1>
                        <p style="color: #666; margin: 10px 0; font-size: 14px;">åŸºæ–¼æ°¸çºŒç›¸é—œè²¡å‹™è³‡è¨Šæ­éœ²æ¨™æº–çš„æ™ºæ…§åˆ†æå ±å‘Š</p>
                        <p style="color: #888; margin: 0; font-size: 12px;">ç”Ÿæˆæ™‚é–“ï¼š${currentDate}</p>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-bottom: 30px;">
                        <div style="text-align: center; padding: 15px; background: #f5f5f5; border-radius: 8px;">
                            <div style="font-size: 18px; font-weight: bold; color: #1976d2;">${fileName}</div>
                            <div style="font-size: 12px; color: #666;">åˆ†ææ–‡ä»¶</div>
                        </div>
                        <div style="text-align: center; padding: 15px; background: #f5f5f5; border-radius: 8px;">
                            <div style="font-size: 18px; font-weight: bold; color: #1976d2;">${totalPages}</div>
                            <div style="font-size: 12px; color: #666;">ç¸½é æ•¸</div>
                        </div>
                        <div style="text-align: center; padding: 15px; background: #f5f5f5; border-radius: 8px;">
                            <div style="font-size: 18px; font-weight: bold; color: #1976d2;">${semanticResults.length}</div>
                            <div style="font-size: 12px; color: #666;">åŒ¹é…æ¢æ–‡</div>
                        </div>
                        <div style="text-align: center; padding: 15px; background: #f5f5f5; border-radius: 8px;">
                            <div style="font-size: 18px; font-weight: bold; color: #1976d2;">${overallRating}</div>
                            <div style="font-size: 12px; color: #666;">æ•´é«”è©•åƒ¹</div>
                        </div>
                    </div>
                `;

                // æ·»åŠ åŒ¹é…æ¢æ–‡è©³ç´°ä¿¡æ¯
                semanticResults.forEach((result, index) => {
                    const article = result.articleData;
                    const evidences = result.evidences || [];
                    
                    if (evidences.length > 0) {
                        htmlContent += `
                            <div style="margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 8px; page-break-inside: avoid;">
                                <h3 style="color: #1a73e8; border-bottom: 2px solid #1a73e8; padding-bottom: 10px; margin-bottom: 15px;">${article.id}: ${article.title}</h3>
                                
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                                    <div>
                                        <h4 style="color: #333;">æ¢æ–‡å…§å®¹</h4>
                                        <p style="font-size: 14px; color: #555; line-height: 1.6;">${article.content}</p>
                                    </div>
                                    <div>
                                        <h4 style="color: #333;">é—œéµè©</h4>
                                        <div style="display: flex; flex-wrap: wrap; gap: 5px;">
                                            ${(article.keywords || []).map(kw => `<span style="background-color: #e8f0fe; color: #1a73e8; padding: 3px 8px; border-radius: 12px; font-size: 12px;">${kw}</span>`).join('')}
                                        </div>
                                    </div>
                                </div>

                                <h4 style="margin-top: 20px; color: #333;">åŒ¹é…è­‰æ“š</h4>
                                ${evidences.map(e => `
                                    <div style="background-color: #f8f9fa; padding: 10px; margin-top: 10px; border-left: 3px solid #28a745; border-radius: 4px;">
                                        <p style="font-weight: bold;">é ç¢¼: ${e.page}, ç›¸ä¼¼åº¦: ${(e.sim * 100).toFixed(1)}%</p>
                                        <p style="font-style: italic; color: #555;">â€œ...${e.content}...â€</p>
                                        <p style="font-size: 12px; color: #007bff; margin-top: 5px;">åˆ†æ: ${e.reasoning}</p>
                                    </div>
                                `).join('')}
                            </div>
                        `;
                    }
                });

                return htmlContent;
            }

            // æª”æ¡ˆä¸‹è¼‰è¼”åŠ©å‡½æ•¸
            function downloadFile(content, fileName, mimeType) {
                try {
                    console.log(` æº–å‚™ä¸‹è¼‰æª”æ¡ˆ: ${fileName} (${mimeType})`);
                    
                    if (!content) {
                        throw new Error('æª”æ¡ˆå…§å®¹ç‚ºç©º');
                    }
                    
                    const blob = new Blob([content], { type: mimeType + ';charset=utf-8' });
                    console.log(` Blob å¤§å°: ${blob.size} bytes`);
                    
                    const link = document.createElement('a');
                    
                    if (link.download !== undefined) {
                        const url = URL.createObjectURL(blob);
                        link.setAttribute('href', url);
                        link.setAttribute('download', fileName);
                        link.style.visibility = 'hidden';
                        
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(url);
                        
                        console.log(` æª”æ¡ˆå·²æˆåŠŸä¸‹è¼‰: ${fileName}`);
                        
                        // é¡¯ç¤ºç”¨æˆ¶å‹å¥½çš„æˆåŠŸæç¤º
                        if (window.statusElement) {
                            const originalText = window.statusElement.textContent;
                            window.statusElement.textContent = ` æª”æ¡ˆå·²ä¸‹è¼‰: ${fileName}`;
                            setTimeout(() => {
                                window.statusElement.textContent = originalText;
                            }, 3000);
                        }
                        
                    } else {
                        throw new Error('æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´æª”æ¡ˆä¸‹è¼‰åŠŸèƒ½ï¼Œè«‹å‡ç´šç€è¦½å™¨ç‰ˆæœ¬');
                    }
                    
                } catch (error) {
                    console.error(' æª”æ¡ˆä¸‹è¼‰å¤±æ•—:', error);
                    alert(`æª”æ¡ˆä¸‹è¼‰å¤±æ•—: ${error.message}`);
                }
            }

            // HTMLå ±å‘Šå…§å®¹ç”Ÿæˆå‡½æ•¸
            function generateHTMLContent(fileName, totalPages, semanticResults, matchingLevels, overallRating) {
                const currentDate = new Date().toLocaleString();
                
                let htmlContent = `<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IFRS S1 ESGå ±å‘Šåˆ†æ - ${fileName}</title>
    <style>
        body {
            font-family: 'Microsoft JhengHei', 'PingFang TC', sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1000px;
            margin: 0 auto;
            padding: 40px 20px;
            background-color: #fff;
        }
        .author-info {
            text-align: center;
            background: #f8f9fa;
            padding: 20px;
            margin-bottom: 30px;
            border-radius: 8px;
            border-left: 4px solid #1976d2;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid #1976d2;
            padding-bottom: 20px;
        }
        .header h1 {
            color: #1976d2;
            margin: 0;
            font-size: 28px;
        }
        .header p {
            color: #666;
            margin: 10px 0;
        }
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }
        .summary-item {
            text-align: center;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 8px;
        }
        .summary-item .value {
            font-size: 24px;
            font-weight: bold;
            color: #1976d2;
        }
        .summary-item .label {
            font-size: 14px;
            color: #666;
        }
        .article-section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: #fafafa;
        }
        .article-title {
            color: #1a73e8;
            border-bottom: 2px solid #1a73e8;
            padding-bottom: 10px;
            margin-bottom: 15px;
            font-size: 18px;
        }
        .evidence-item {
            margin: 10px 0;
            padding: 10px;
            background: white;
            border-left: 3px solid #4caf50;
            border-radius: 4px;
        }
        .evidence-meta {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }
        .evidence-content {
            color: #333;
        }
        @media print {
            body { margin: 0; padding: 20px; }
            .summary-grid { grid-template-columns: repeat(2, 1fr); }
        }
    </style>
</head>
<body>
    <div class="author-info">
        <h2 style="margin: 0; color: #1976d2;">æ­¤å ±å‘Šç”±AIç”Ÿæˆï¼Œä½œè€…ï¼šæ¸¸å£«å¼˜</h2>
        <p style="margin: 5px 0; color: #666;">åŸºæ–¼IFRS S1æ°¸çºŒç›¸é—œè²¡å‹™è³‡è¨Šæ­éœ²æ¨™æº–çš„æ™ºæ…§åˆ†æ</p>
    </div>
    
    <div class="header">
        <h1>IFRS S1 ESGå ±å‘Šåˆ†æ</h1>
        <p>åŸºæ–¼æ°¸çºŒç›¸é—œè²¡å‹™è³‡è¨Šæ­éœ²æ¨™æº–çš„æ™ºæ…§åˆ†æå ±å‘Š</p>
        <p>ç”Ÿæˆæ™‚é–“ï¼š${currentDate}</p>
    </div>
    
    <div class="summary-grid">
        <div class="summary-item">
            <div class="value">${fileName}</div>
            <div class="label">åˆ†ææ–‡ä»¶</div>
        </div>
        <div class="summary-item">
            <div class="value">${totalPages}</div>
            <div class="label">ç¸½é æ•¸</div>
        </div>
        <div class="summary-item">
            <div class="value">${semanticResults.length}</div>
            <div class="label">åŒ¹é…æ¢æ–‡</div>
        </div>
        <div class="summary-item">
            <div class="value">${(overallRating && overallRating.rating) ? `${overallRating.rating.level}ï¼ˆ${overallRating.rating.score}åˆ†ï¼‰` : 'N/A'}</div>
            <div class="label">æ•´é«”è©•åƒ¹</div>
        </div>
    </div>
    <div class="article-section">
        <h3 class="article-title">æ•´é«”è©•åƒ¹</h3>
        <p><strong>ç¬¦åˆç¨‹åº¦ï¼š</strong>${(overallRating && overallRating.rating) ? `${overallRating.rating.level}ï¼ˆ${overallRating.rating.score}åˆ†ï¼‰` : 'N/A'}ï¼›åŒ¹é…ç‡ ${(overallRating && overallRating.statistics) ? `${overallRating.statistics.matchingRate}%` : '-'}ã€åŠ æ¬Šå¾—åˆ† ${(overallRating && overallRating.statistics) ? `${overallRating.statistics.weightedScore}%` : '-'}</p>
        <p><strong>æ•´é«”æè¿°ï¼š</strong>${(overallRating && overallRating.description) ? overallRating.description : ''}</p>
        <p><strong>å»ºè­°ï¼š</strong>${(overallRating && overallRating.recommendation) ? overallRating.recommendation : ''}</p>
    </div>`;

                // æ·»åŠ åŒ¹é…æ¢æ–‡è©³ç´°ä¿¡æ¯
                semanticResults.forEach((result, index) => {
                    const article = result.articleData;
                    const evidences = result.evidences || [];
                    
                    if (evidences.length > 0) {
                        htmlContent += `
                            <div class="article-section">
                                <h3 class="article-title">${article.id}: ${article.title}</h3>
                                
                                <div style="margin-bottom: 15px;">
                                    <strong>æ¢æ–‡å…§å®¹ï¼š</strong>
                                    <p style="background: white; padding: 10px; border-radius: 4px; margin: 5px 0;">${article.content}</p>
                                </div>
                                
                                <div>
                                    <strong>æ–‡ä»¶è­‰æ“šï¼š</strong>`;
                        
                        evidences.forEach((evidence, evidenceIndex) => {
                            const similarity = (evidence.similarity || evidence.sim || 0) * 100;
                            htmlContent += `
                                <div class="evidence-item">
                                    <div class="evidence-meta">
                                        ç›¸ä¼¼åº¦: ${similarity.toFixed(1)}% | 
                                        é¡å‹: ${evidence.source || 'èªå¥åŒ¹é…'} | 
                                        é é¢: ${evidence.page || 'æœªçŸ¥'}
                                    </div>
                                    <div class="evidence-content">${evidence.text || evidence.sentence || 'å…§å®¹æœªçŸ¥'}</div>
                                </div>`;
                        });
                        
                        htmlContent += `
                                </div>
                            </div>`;
                    }
                });

                htmlContent += `
</body>
</html>`;
                
                return htmlContent;
            }

            //  IFRS S1 å»ºè­°æ›¸ç”ŸæˆåŠŸèƒ½ (åŸºæ–¼ Dual AI Model)
            let currentRecommendationData = null;

            async function generateIFRSRecommendation() {
                if (!analysisReportData || !analysisReportData.results) {
                    alert('è«‹å…ˆå®ŒæˆPDFåˆ†æå¾Œå†ç”Ÿæˆå»ºè­°æ›¸');
                    return;
                }

                // é¡¯ç¤ºæ¨¡æ…‹çª—å£
                document.getElementById('recommendationModal').style.display = 'block';
                document.getElementById('recommendationStatus').textContent = ' AIæ­£åœ¨åˆ†æåˆ†æçµæœ...';
                
                // é‡ç½®å…§å®¹ç‚ºåŠ è¼‰ç‹€æ…‹
                document.getElementById('recommendationContent').innerHTML = `
                    <div class="loading-ai">
                        <div class="spinner-ai"></div>
                        <p> é›™AIæ¨¡å‹æ­£åœ¨åˆ†ææ‚¨çš„å ±å‘Šä¸¦ç”ŸæˆIFRS S1å»ºè­°æ›¸...</p>
                        <p style="font-size: 0.9em; color: #888;">çµåˆEmbeddingGemmaå’ŒQwen3çš„èªç¾©åˆ†æçµæœ</p>
                    </div>`;

                try {
                    // èª¿ç”¨å¾Œç«¯dual AI modelé€²è¡Œå»ºè­°æ›¸ç”Ÿæˆ
                    const recommendationData = await generateRecommendationWithDualAI();
                    
                    if (recommendationData) {
                        currentRecommendationData = recommendationData;
                        displayRecommendation(recommendationData);
                        document.getElementById('recommendationStatus').textContent = ' å»ºè­°æ›¸ç”Ÿæˆå®Œæˆ';
                    } else {
                        throw new Error('ç„¡æ³•ç”Ÿæˆå»ºè­°æ›¸å…§å®¹');
                    }
                    
                } catch (error) {
                    console.error('å»ºè­°æ›¸ç”Ÿæˆå¤±æ•—:', error);
                    document.getElementById('recommendationContent').innerHTML = `
                        <div style="text-align: center; padding: 50px; color: #d93025;">
                            <h3> ç”Ÿæˆå¤±æ•—</h3>
                            <p>ç„¡æ³•ç”ŸæˆIFRS S1å»ºè­°æ›¸ï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£æ¥æˆ–ç¨å¾Œé‡è©¦</p>
                            <p style="font-size: 0.9em; color: #666;">éŒ¯èª¤: ${error.message}</p>
                            <button class="recommendation-btn primary" onclick="generateIFRSRecommendation()" style="margin-top: 20px;">
                                 é‡æ–°å˜—è©¦
                            </button>
                        </div>`;
                    document.getElementById('recommendationStatus').textContent = ' ç”Ÿæˆå¤±æ•—';
                }
            }

            async function generateRecommendationWithDualAI() {
                const { fileName, totalPages, analysisDate, results } = analysisReportData;
                const semanticResults = results.filter(r => {
                    const evidences = r.evidences || [];
                    return evidences.length > 0 && evidences.some(ev => ev.coreHit > 0 || ev.sim > 0.01);
                });

                // æº–å‚™ç™¼é€çµ¦Dual AI Modelçš„æ•¸æ“š
                const aiInputData = {
                    metadata: {
                        fileName,
                        totalPages,
                        analysisDate,
                        semanticMatchCount: semanticResults.length,
                        totalArticleCount: results.length
                    },
                    analysis_summary: {
                        matched_articles: semanticResults.map(result => ({
                            article_id: result.articleData.id,
                            title: result.articleData.title,
                            category: result.articleData.category,
                            difficulty: result.articleData.difficulty,
                            evidence_count: result.evidences.length,
                            max_similarity: Math.max(...result.evidences.map(e => e.sim)),
                            key_evidence: result.evidences.slice(0, 2).map(e => ({
                                content: e.content,
                                similarity: e.sim,
                                reasoning: e.reasoning,
                                page: e.page
                            }))
                        })),
                        categories_analysis: getCategoriesAnalysis(semanticResults),
                        compliance_gaps: getComplianceGaps(results, semanticResults)
                    }
                };

                console.log(' ç™¼é€æ•¸æ“šçµ¦Dual AI Model:', aiInputData);

                try {
                    // èª¿ç”¨å¾Œç«¯dual model fusionæœå‹™é€²è¡Œæ™ºæ…§åˆ†æï¼ˆæ”¹ç‚º8004ï¼Œä¸¦åŠ å…¥å‚™æ´ï¼‰
                    const response = await fetch('http://localhost:8004/generate_recommendation', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            file_name: fileName,
                            total_pages: totalPages,
                            analysis_date: analysisDate,
                            results: semanticResults,
                            summary: {
                                matched_articles: semanticResults.length,
                                total_articles: results.length
                            },
                            language: 'zh-TW'
                        })
                    });

                    if (response.ok) {
                        const aiResponse = await response.json();
                        console.log(' Dual AI ModeléŸ¿æ‡‰:', aiResponse);
                        return aiResponse;
                    } else {
                        throw new Error(`APIè«‹æ±‚å¤±æ•—: ${response.status}`);
                    }
                } catch (apiError) {
                    console.warn('Dual AI APIä¸å¯ç”¨ï¼Œä½¿ç”¨æœ¬åœ°ç”Ÿæˆ:', apiError);
                    // é™ç´šç‚ºæœ¬åœ°æ™ºæ…§ç”Ÿæˆ
                    return generateLocalRecommendation(aiInputData);
                }
            }

            function getCategoriesAnalysis(semanticResults) {
                const categories = {};
                semanticResults.forEach(result => {
                    const category = result.articleData.category;
                    if (!categories[category]) {
                        categories[category] = {
                            count: 0,
                            avg_similarity: 0,
                            articles: []
                        };
                    }
                    categories[category].count++;
                    categories[category].articles.push({
                        id: result.articleData.id,
                        title: result.articleData.title,
                        max_similarity: Math.max(...result.evidences.map(e => e.sim))
                    });
                });
                
                // è¨ˆç®—å¹³å‡ç›¸ä¼¼åº¦
                Object.keys(categories).forEach(category => {
                    const avgSim = categories[category].articles.reduce((sum, art) => sum + art.max_similarity, 0) / categories[category].articles.length;
                    categories[category].avg_similarity = avgSim;
                });

                return categories;
            }

            function getComplianceGaps(allResults, semanticResults) {
                const matchedIds = new Set(semanticResults.map(r => r.articleData.id));
                const gaps = allResults.filter(r => !matchedIds.has(r.articleData.id));
                
                return gaps.map(gap => ({
                    article_id: gap.articleData.id,
                    title: gap.articleData.title,
                    category: gap.articleData.category,
                    difficulty: gap.articleData.difficulty,
                    reason: gap.evidences.length === 0 ? "ç„¡èªç¾©è­‰æ“š" : "ç›¸ä¼¼åº¦éä½"
                }));
            }

            function generateLocalRecommendation(inputData) {
                // æœ¬åœ°æ™ºæ…§ç”Ÿæˆå»ºè­°æ›¸ (å‚™æ´æ¨¡å¼)
                console.log(' ä½¿ç”¨æœ¬åœ°ç”Ÿæˆæ¨¡å¼');
                
                const { metadata, analysis_summary } = inputData;
                const { matched_articles, categories_analysis, compliance_gaps } = analysis_summary;

                // ç”Ÿæˆå»ºè­°æ›¸çµæ§‹
                const recommendation = {
                    title: `${metadata.fileName} - IFRS S1 æ°¸çºŒè³‡è¨Šæ­éœ²å»ºè­°æ›¸`,
                    generated_at: new Date().toISOString(),
                    model_used: "local-intelligent-generation",
                    sections: {
                        executive_summary: generateExecutiveSummary(metadata, analysis_summary),
                        compliance_status: generateComplianceStatus(matched_articles, categories_analysis),
                        gap_analysis: generateGapAnalysis(compliance_gaps),
                        recommendations: generateRecommendations(categories_analysis, compliance_gaps),
                        action_plan: generateActionPlan(categories_analysis, compliance_gaps),
                        evidence_detail: generateEvidenceDetail(matched_articles)
                    }
                };

                return recommendation;
            }

            function generateExecutiveSummary(metadata, analysis_summary) {
                const { matched_articles, compliance_gaps } = analysis_summary;
                const complianceRate = (matched_articles.length / (matched_articles.length + compliance_gaps.length) * 100).toFixed(1);
                
                return {
                    title: "åŸ·è¡Œæ‘˜è¦",
                    content: `
                        <p>æœ¬å ±å‘Šé‡å°ã€Œ${metadata.fileName}ã€é€²è¡ŒIFRS S1æ°¸çºŒç›¸é—œè²¡å‹™è³‡è¨Šæ­éœ²æ¨™æº–çš„åˆè¦æ€§åˆ†æã€‚ç¶“ç”±é›™AIæ¨¡å‹èªç¾©åˆ†æï¼Œç™¼ç¾è©²å ±å‘Šåœ¨æ°¸çºŒè³‡è¨Šæ­éœ²æ–¹é¢çš„æ•´é«”åˆè¦ç‡ç‚º<strong>${complianceRate}%</strong>ã€‚</p>
                        
                        <div class="recommendation-highlight">
                            <strong>é—œéµç™¼ç¾ï¼š</strong>
                            <ul>
                                <li>å…±è­˜åˆ¥å‡º ${matched_articles.length} é …ç¬¦åˆIFRS S1æ¨™æº–çš„æ­éœ²å…§å®¹</li>
                                <li>éœ€è¦æ”¹é€²çš„é ˜åŸŸï¼š${compliance_gaps.length} é …æ¢æ–‡ç¼ºä¹å……åˆ†è­‰æ“š</li>
                                <li>å ±å‘Šç¸½é æ•¸ï¼š${metadata.totalPages} é </li>
                                <li>åˆ†æå®Œæˆæ™‚é–“ï¼š${new Date(metadata.analysisDate).toLocaleDateString()}</li>
                            </ul>
                        </div>
                        
                        <p>å»ºè­°å„ªå…ˆé—œæ³¨<strong>æ²»ç†çµæ§‹</strong>å’Œ<strong>é¢¨éšªç®¡ç†</strong>é ˜åŸŸçš„è³‡è¨Šæ­éœ²ï¼Œä»¥æå‡æ•´é«”åˆè¦æ°´æº–ã€‚</p>
                    `
                };
            }

            function generateComplianceStatus(matched_articles, categories_analysis) {
                let statusContent = `
                    <p>æ ¹æ“šIFRS S1æ¨™æº–çš„å››å¤§æ”¯æŸ±åˆ†æï¼Œå„é¡åˆ¥åˆè¦ç‹€æ³å¦‚ä¸‹ï¼š</p>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin: 20px 0;">
                `;

                Object.entries(categories_analysis).forEach(([category, data]) => {
                    const icon = getCategoryIcon(category);
                    const score = (data.avg_similarity * 100).toFixed(1);
                    const level = score >= 70 ? 'å„ªç§€' : score >= 50 ? 'è‰¯å¥½' : score >= 30 ? 'å¾…æ”¹å–„' : 'ä¸è¶³';
                    const color = score >= 70 ? '#4CAF50' : score >= 50 ? '#FF9800' : score >= 30 ? '#FF5722' : '#D32F2F';
                    
                    statusContent += `
                        <div style="background: white; border: 2px solid ${color}; border-radius: 12px; padding: 20px; text-align: center;">
                            <div style="font-size: 2em; margin-bottom: 10px;">${icon}</div>
                            <h4 style="margin: 10px 0; color: ${color};">${category}</h4>
                            <div style="font-size: 1.2em; font-weight: bold; color: ${color};">${score}%</div>
                            <div style="font-size: 0.9em; color: #666;">${level} (${data.count}é …)</div>
                        </div>
                    `;
                });

                statusContent += `</div>`;
                
                return {
                    title: "åˆè¦ç‹€æ³åˆ†æ",
                    content: statusContent
                };
            }

            function generateGapAnalysis(compliance_gaps) {
                if (compliance_gaps.length === 0) {
                    return {
                        title: "å·®è·åˆ†æ",
                        content: `
                            <div class="recommendation-highlight">
                                <strong> æ­å–œï¼</strong> æ‚¨çš„å ±å‘Šå·²æ¶µè“‹æ‰€æœ‰é‡è¦çš„IFRS S1æ­éœ²è¦æ±‚ï¼Œæœªç™¼ç¾é‡å¤§åˆè¦å·®è·ã€‚
                            </div>
                        `
                    };
                }

                let gapContent = `
                    <p>ä»¥ä¸‹ ${compliance_gaps.length} é …IFRS S1æ¢æ–‡åœ¨ç•¶å‰å ±å‘Šä¸­ç¼ºä¹å……åˆ†çš„èªç¾©è­‰æ“šï¼š</p>
                    <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 8px; padding: 20px; margin: 20px 0;">
                `;

                compliance_gaps.slice(0, 8).forEach((gap, index) => {
                    const priority = gap.difficulty === 'high' ? ' é«˜' : gap.difficulty === 'medium' ? 'ğŸŸ¡ ä¸­' : 'ğŸŸ¢ ä½';
                    gapContent += `
                        <div style="margin-bottom: 15px; padding: 10px; background: white; border-radius: 6px;">
                            <strong>${gap.article_id}:</strong> ${gap.title}
                            <br><small style="color: #666;">é¡åˆ¥: ${gap.category} | å„ªå…ˆç´š: ${priority} | åŸå› : ${gap.reason}</small>
                        </div>
                    `;
                });

                if (compliance_gaps.length > 8) {
                    gapContent += `<p><em>...é‚„æœ‰ ${compliance_gaps.length - 8} é …å…¶ä»–æ¢æ–‡éœ€è¦é—œæ³¨</em></p>`;
                }

                gapContent += `</div>`;

                return {
                    title: "å·®è·åˆ†æ",
                    content: gapContent
                };
            }

            function generateRecommendations(categories_analysis, compliance_gaps) {
                let recommendations = [];

                // åŸºæ–¼é¡åˆ¥åˆ†æç”Ÿæˆå»ºè­°
                Object.entries(categories_analysis).forEach(([category, data]) => {
                    if (data.avg_similarity < 0.5) {
                        recommendations.push(`åŠ å¼·<strong>${category}</strong>é ˜åŸŸçš„è³‡è¨Šæ­éœ²ï¼Œç›®å‰å¹³å‡åˆè¦åº¦åƒ…${(data.avg_similarity * 100).toFixed(1)}%`);
                    }
                });

                // åŸºæ–¼å·®è·åˆ†æç”Ÿæˆå»ºè­°
                const highPriorityGaps = compliance_gaps.filter(gap => gap.difficulty === 'high');
                if (highPriorityGaps.length > 0) {
                    recommendations.push(`å„ªå…ˆè™•ç† ${highPriorityGaps.length} é …é«˜å„ªå…ˆç´šæ¢æ–‡çš„åˆè¦å•é¡Œ`);
                }

                // é€šç”¨å»ºè­°
                recommendations.push(
                    "å»ºç«‹å®Œæ•´çš„æ°¸çºŒè³‡è¨Šç®¡ç†ç³»çµ±ï¼Œç¢ºä¿æ•¸æ“šæ”¶é›†çš„å®Œæ•´æ€§å’Œæº–ç¢ºæ€§",
                    "å¼·åŒ–å…§éƒ¨æ§åˆ¶åˆ¶åº¦ï¼Œå»ºç«‹æ°¸çºŒè³‡è¨Šçš„å¯©æ ¸å’Œé©—è­‰æ©Ÿåˆ¶",
                    "å®šæœŸæª¢è¦–IFRS S1æ¨™æº–çš„æ›´æ–°ï¼Œç¢ºä¿æ­éœ²å…§å®¹èˆ‡æœ€æ–°è¦æ±‚ä¸€è‡´"
                );

                let recContent = `<ol>`;
                recommendations.forEach(rec => {
                    recContent += `<li style="margin-bottom: 10px;">${rec}</li>`;
                });
                recContent += `</ol>`;

                return {
                    title: "æ”¹å–„å»ºè­°",
                    content: recContent
                };
            }

            function generateActionPlan(categories_analysis, compliance_gaps) {
                const actions = [
                    {
                        phase: "ç¬¬ä¸€éšæ®µ (1-3å€‹æœˆ)",
                        icon: "",
                        tasks: [
                            "å®Œæˆé«˜å„ªå…ˆç´šæ¢æ–‡çš„è³‡è¨Šæ”¶é›†",
                            "å»ºç«‹æ°¸çºŒè³‡è¨ŠæŠ«éœ²å·¥ä½œå°çµ„",
                            "åˆ¶å®šè©³ç´°çš„åˆè¦æ™‚ç¨‹è¡¨"
                        ]
                    },
                    {
                        phase: "ç¬¬äºŒéšæ®µ (3-6å€‹æœˆ)",
                        icon: "",
                        tasks: [
                            "å¯¦æ–½è³‡è¨Šç®¡ç†ç³»çµ±å‡ç´š",
                            "å®Œæˆä¸­ç­‰å„ªå…ˆç´šæ¢æ–‡çš„åˆè¦æ”¹å–„",
                            "å»ºç«‹å…§éƒ¨å¯©æ ¸åˆ¶åº¦"
                        ]
                    },
                    {
                        phase: "ç¬¬ä¸‰éšæ®µ (6-12å€‹æœˆ)",
                        icon: "",
                        tasks: [
                            "å®Œæˆæ‰€æœ‰æ¢æ–‡çš„åˆè¦æª¢æŸ¥",
                            "ç™¼å¸ƒå®Œæ•´çš„IFRS S1åˆè¦å ±å‘Š",
                            "å»ºç«‹æŒçºŒæ”¹å–„æ©Ÿåˆ¶"
                        ]
                    }
                ];

                let actionContent = "";
                actions.forEach(action => {
                    actionContent += `
                        <div class="recommendation-evidence">
                            <h4>${action.icon} ${action.phase}</h4>
                            <ul>
                                ${action.tasks.map(task => `<li>${task}</li>`).join('')}
                            </ul>
                        </div>
                    `;
                });

                return {
                    title: "è¡Œå‹•è¨ˆç•«",
                    content: actionContent
                };
            }

            function generateEvidenceDetail(matched_articles) {
                let evidenceContent = `
                    <p>ä»¥ä¸‹ç‚ºå…·æœ‰é«˜åº¦èªç¾©è­‰æ“šçš„IFRS S1æ¢æ–‡åŒ¹é…è©³æƒ…ï¼š</p>
                `;

                matched_articles.slice(0, 5).forEach(article => {
                    evidenceContent += `
                        <div class="recommendation-evidence">
                            <div class="recommendation-evidence-title">
                                ${article.article_id}: ${article.title}
                            </div>
                            <p><strong>é¡åˆ¥ï¼š</strong>${article.category} | <strong>æœ€é«˜ç›¸ä¼¼åº¦ï¼š</strong>${(article.max_similarity * 100).toFixed(1)}%</p>
                            <div style="margin-top: 10px;">
                                <strong>é—œéµè­‰æ“šï¼š</strong>
                                <ul>
                                    ${article.key_evidence.map(ev => `
                                        <li style="margin-bottom: 5px;">
                                            [é ${ev.page}] ${ev.content.substring(0, 100)}... (ç›¸ä¼¼åº¦: ${(ev.similarity * 100).toFixed(1)}%)
                                        </li>
                                    `).join('')}
                                </ul>
                            </div>
                        </div>
                    `;
                });

                if (matched_articles.length > 5) {
                    evidenceContent += `<p><em>...å…± ${matched_articles.length} é …æ¢æ–‡æœ‰èªç¾©è­‰æ“šæ”¯æŒ</em></p>`;
                }

                return {
                    title: "è­‰æ“šè©³æƒ…",
                    content: evidenceContent
                };
            }

            function getCategoryIcon(category) {
                const icons = {
                    'æ²»ç†': '',
                    'ç­–ç•¥': '',
                    'é¢¨éšªç®¡ç†': '',
                    'æŒ‡æ¨™èˆ‡ç›®æ¨™': '',
                    'å ±å‘ŠåŸºç¤': ''
                };
                return icons[category] || '';
            }

            function displayRecommendation(recommendationData) {
                const { title, sections } = recommendationData;
                
                let contentHTML = `
                    <div class="recommendation-document">
                        <h1>${title}</h1>
                        <p style="text-align: center; color: #666; font-style: italic;">
                            ç”Ÿæˆæ™‚é–“: ${new Date().toLocaleString()} | 
                            åŸºæ–¼: é›™AIæ¨¡å‹èªç¾©åˆ†æ (EmbeddingGemma + Qwen3)
                        </p>
                `;

                // æ¸²æŸ“å„å€‹ç« ç¯€
                Object.entries(sections).forEach(([key, section]) => {
                    contentHTML += `
                        <h2>${section.title}</h2>
                        ${section.content}
                    `;
                });

                contentHTML += `
                        <div style="margin-top: 50px; padding: 20px; background: #f8f9ff; border-radius: 8px; border: 1px solid #e1e5e9;">
                            <h3> AIç”Ÿæˆèªªæ˜</h3>
                            <p>æœ¬å»ºè­°æ›¸ç”±é›™AIæ¨¡å‹ (EmbeddingGemma-300M + Qwen3-Embedding-0.6B) åŸºæ–¼èªç¾©åˆ†æçµæœè‡ªå‹•ç”Ÿæˆã€‚å»ºè­°å…§å®¹åƒ…ä¾›åƒè€ƒï¼Œå¯¦éš›åŸ·è¡Œæ™‚è«‹çµåˆä¼æ¥­å…·é«”æƒ…æ³å’Œå°ˆæ¥­é¡§å•æ„è¦‹ã€‚</p>
                            <p><strong>æŠ€è¡“æ¶æ§‹ï¼š</strong>é›™æ¨¡å‹èåˆèªç¾©åˆ†æ + æ™ºæ…§å…§å®¹ç”Ÿæˆ</p>
                            <p><strong>ç”Ÿæˆç‰ˆæœ¬ï¼š</strong>IFRS S1 ESG å ±å‘Šåˆ†æå·¥å…· v6.0</p>
                        </div>
                    </div>
                `;

                document.getElementById('recommendationContent').innerHTML = contentHTML;
            }

            function closeRecommendationModal() {
                document.getElementById('recommendationModal').style.display = 'none';
            }

            function regenerateRecommendation() {
                if (confirm('ç¢ºå®šè¦é‡æ–°ç”Ÿæˆå»ºè­°æ›¸å—ï¼Ÿé€™å°‡è¦†è“‹ç•¶å‰å…§å®¹ã€‚')) {
                    generateIFRSRecommendation();
                }
            }

            function downloadRecommendationReport() {
                if (!currentRecommendationData) {
                    alert('æ²’æœ‰å¯ä¸‹è¼‰çš„å»ºè­°æ›¸æ•¸æ“š');
                    return;
                }

                const { fileName } = analysisReportData;
                const documentContent = document.getElementById('recommendationContent').innerHTML;
                
                const fullHTML = `
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IFRS S1 å»ºè­°æ›¸ - ${fileName}</title>
    <style>
        body { font-family: 'Microsoft JhengHei', 'Times New Roman', serif; line-height: 1.8; margin: 20px; color: #333; }
        .recommendation-document h1 { text-align: center; color: #1a73e8; border-bottom: 3px solid #1a73e8; padding-bottom: 20px; margin-bottom: 30px; }
        .recommendation-document h2 { color: #34a853; margin-top: 40px; margin-bottom: 20px; border-left: 4px solid #34a853; padding-left: 15px; }
        .recommendation-document h3 { color: #ea4335; margin-top: 25px; margin-bottom: 15px; }
        .recommendation-highlight { background: linear-gradient(120deg, #a8e6cf 0%, #dcedc8 100%); padding: 20px; border-radius: 8px; border-left: 4px solid #4CAF50; margin: 20px 0; }
        .recommendation-evidence { background: #f8f9ff; border: 1px solid #e8eaed; border-radius: 8px; padding: 15px; margin: 15px 0; }
        .recommendation-evidence-title { font-weight: 600; color: #1a73e8; margin-bottom: 10px; }
        @media print { body { font-size: 12px; } .no-print { display: none; } }
    </style>
</head>
<body>
    ${documentContent}
    <div class="no-print" style="margin-top: 30px; font-size: 0.9em; color: #666; text-align: center;">
        ä¸‹è¼‰æ™‚é–“: ${new Date().toLocaleString()} | IFRS S1 ESG å ±å‘Šåˆ†æå·¥å…· v6.0
    </div>
</body>
</html>`;

                downloadFile(fullHTML, `IFRS_S1_å»ºè­°æ›¸_${fileName}_${new Date().toISOString().split('T')[0]}.html`, 'text/html');
            }

            function printRecommendationReport() {
                if (!currentRecommendationData) {
                    alert('æ²’æœ‰å¯åˆ—å°çš„å»ºè­°æ›¸');
                    return;
                }

                const printWindow = window.open('', '_blank');
                const documentContent = document.getElementById('recommendationContent').innerHTML;
                
                printWindow.document.write(`
<!DOCTYPE html>
<html>
<head>
    <title>IFRS S1 å»ºè­°æ›¸ - ${analysisReportData.fileName}</title>
    <style>
        body { font-family: 'Microsoft JhengHei', sans-serif; line-height: 1.6; margin: 20px; }
        .recommendation-document h1 { text-align: center; color: #1a73e8; border-bottom: 2px solid #1a73e8; padding-bottom: 15px; }
        .recommendation-document h2 { color: #34a853; margin-top: 30px; border-left: 4px solid #34a853; padding-left: 10px; }
        .recommendation-highlight { background: #f0f8ff; padding: 15px; border: 1px solid #1a73e8; border-radius: 4px; margin: 15px 0; }
        .recommendation-evidence { background: #f8f9ff; border: 1px solid #e8eaed; border-radius: 4px; padding: 10px; margin: 10px 0; }
        @page { margin: 1in; }
        @media print { body { font-size: 11px; } }
    </style>
</head>
<body>
    ${documentContent}
    <div style="margin-top: 30px; font-size: 0.9em; color: #666;">
        åˆ—å°æ™‚é–“: ${new Date().toLocaleString()}
    </div>
</body>
</html>`);
                
                printWindow.document.close();
                printWindow.focus();
                
                setTimeout(() => {
                    printWindow.print();
                    printWindow.close();
                }, 500);
            }

            // é»æ“Šæ¨¡æ…‹çª—å£å¤–éƒ¨é—œé–‰
            window.onclick = function(event) {
                const modal = document.getElementById('recommendationModal');
                if (event.target === modal) {
                    closeRecommendationModal();
                }
            };

            // Function to load Chinese fonts if not available
            async function loadChineseFonts() {
                const fonts = [
                    { name: 'Microsoft JhengHei', url: 'https://fonts.gstatic.com/s/jetbrainsmono/v13/tDbY2o9AswtU38rmzDUnwv1sK9gbWtRj7wP9kKJ4.ttf' },
                    { name: 'Microsoft YaHei', url: 'https://fonts.gstatic.com/s/notosanssc/v36/k3kXo84MPvpLmixcA63oeALhL4iJ-Q7m8w.otf' },
                    { name: 'SimHei', url: 'https://fonts.gstatic.com/s/notosanssc/v36/k3kXo84MPvpLmixcA63oeALhL4iJ-Q7m8w.otf' },
                    { name: 'SimSun', url: 'https://fonts.gstatic.com/s/notosanssc/v36/k3kXo84MPvpLmixcA63oeALhL4iJ-Q7m8w.otf' }
                ];

                const fontPromises = fonts.map(font => {
                    return new Promise((resolve) => {
                        // Check if font is already loaded
                        if (document.fonts.check(`16px "${font.name}"`)) {
                            return resolve();
                        }
                        
                        // Load font if not available
                        const fontFace = new FontFace(font.name, `url(${font.url})`);
                        document.fonts.add(fontFace);
                        
                        fontFace.loaded.then(() => {
                            console.log(`[FONT] ${font.name} loaded successfully`);
                            resolve();
                        }).catch(err => {
                            console.warn(`[FONT] Failed to load ${font.name}:`, err);
                            resolve(); // Resolve anyway to not block the app
                        });
                    });
                });

                return Promise.all(fontPromises);
            }

            // --- Main Execution ---
            (async () => {
                initializeIFRSData();
                await initializeSystemStatus();
                setupEventListeners();
                await loadChineseFonts();
                // Do not block the main thread on preloading PDFs; update UI asynchronously
                preloadPDFFiles();
                console.log(' IFRS S1 åˆ†æå·¥å…·å·²å°±ç·’');
                // æª¢æŸ¥å¾Œç«¯èªç¾©æœå‹™ç‹€æ…‹ä¸¦é¡¯ç¤ºæ¨¡å‹/è¨­å‚™ä¿¡æ¯
                try {
                    const res = await fetchWithTimeout('http://localhost:8004/health', { cache: 'no-store' }, 6000);
                    if (res.ok) {
                        const info = await res.json();
                        const device = info.device || 'cpu';
                        let model = 'semantic-service';
                        if (info.models && info.models.faiss_retrieval) {
                            model = 'faiss-hybrid-accelerated';
                        } else if (info.models && info.models.dual_fusion) {
                            model = 'dual-gemma-qwen3-fused';
                        }
                        
                        // é¡¯ç¤ºç¡¬é«”åŠ é€Ÿç‹€æ…‹
                        const statusDiv = document.getElementById('hardware-acceleration-status');
                        const detailsDiv = document.getElementById('acceleration-details');
                        
                        if (statusDiv && detailsDiv) {
                            let accelerationInfo = '';
                            if (device === 'mps') {
                                accelerationInfo = ' MPS (Metal Performance Shaders) åŠ é€Ÿå·²å•Ÿç”¨<br> ä½¿ç”¨ Apple Silicon NPU é€²è¡Œèªç¾©è¨ˆç®—';
                            } else if (device === 'cuda') {
                                accelerationInfo = ' CUDA GPU åŠ é€Ÿå·²å•Ÿç”¨<br> ä½¿ç”¨ NVIDIA GPU é€²è¡Œèªç¾©è¨ˆç®—';
                            } else {
                                accelerationInfo = `â„¹ï¸ ä½¿ç”¨ ${device.toUpperCase()} é‹ç®—<br> å·²è¼‰å…¥ ${info.indexed_articles || 0} æ¢ IFRS S1 æ¢æ–‡`;
                            }
                            
                            if (info.models && info.models.faiss_retrieval) {
                                accelerationInfo += '<br> FAISS å‘é‡æª¢ç´¢å·²å„ªåŒ–<br> Sentence Transformers èªç¾©æ¨¡å‹å·²è¼‰å…¥';
                            }
                            
                            detailsDiv.innerHTML = accelerationInfo;
                            statusDiv.style.display = 'block';
                        }
                        
                        document.getElementById('status-semantic').textContent = `Online (${model}, ${device})`;
                    } else {
                        document.getElementById('status-semantic').textContent = 'Offline';
                    }
                } catch (e) {
                    const el = document.getElementById('status-semantic');
                    if (el && (!el.textContent || el.textContent.includes('Checking'))) {
                        el.textContent = 'Offline (ä½¿ç”¨é—œéµè©åŒ¹é…)';
                    }
                }
            })();
        });
    </script>
</body>
</html>
